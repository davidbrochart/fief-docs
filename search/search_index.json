{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Fief? \u00b6 Fief is an open-source platform to manage users and authentication in your applications. Our goal is to help you manage users and security in a matter of minutes, not days. Key features: Pre-built login and registration pages Users management dashboard SDK for the most popular languages and frameworks Integrations for the most popular no-code tools Bring Your Own Database : you can connect to any SQL database so you keep entire control of your data Cloud vs Self-hosted \u00b6 We are offering two ways of using Fief: Cloud : fair-priced hosted instance, maintained by the Fief's team; Self-hosted : you host the service yourself on your own infrastructure, for free.","title":"What is Fief?"},{"location":"#what-is-fief","text":"Fief is an open-source platform to manage users and authentication in your applications. Our goal is to help you manage users and security in a matter of minutes, not days. Key features: Pre-built login and registration pages Users management dashboard SDK for the most popular languages and frameworks Integrations for the most popular no-code tools Bring Your Own Database : you can connect to any SQL database so you keep entire control of your data","title":"What is Fief?"},{"location":"#cloud-vs-self-hosted","text":"We are offering two ways of using Fief: Cloud : fair-priced hosted instance, maintained by the Fief's team; Self-hosted : you host the service yourself on your own infrastructure, for free.","title":"Cloud vs Self-hosted"},{"location":"getting-started/admin-dashboard/","text":"Admin dashboard \u00b6 The admin dashboard is the interface where you'll be able to manage your Fief workspace and configuration. The left menu lets you access to the most important aspects of Fief: Tenants Clients Users API Keys Switch workspace \u00b6 If your account is linked to several workspaces, you can switch to another workspace using the menu on the top-right.","title":"Admin dashboard"},{"location":"getting-started/admin-dashboard/#admin-dashboard","text":"The admin dashboard is the interface where you'll be able to manage your Fief workspace and configuration. The left menu lets you access to the most important aspects of Fief: Tenants Clients Users API Keys","title":"Admin dashboard"},{"location":"getting-started/admin-dashboard/#switch-workspace","text":"If your account is linked to several workspaces, you can switch to another workspace using the menu on the top-right.","title":"Switch workspace"},{"location":"getting-started/api-keys/","text":"API Keys \u00b6 This is where you'll see and manage the api keys of your workspace. What is an API key? An API key is a secret token that'll allow you to make authenticated requests to the Fief Admin API . It'll be useful if you need, for example, to manage tenants or clients programmatically from your own application. Keep it secret and safe An API key gives complete accesss to your workspace data. Keep it somewhere safe and don't share it with anyone. Create a new API Key \u00b6 To create a new API Key, click on the Create API Key button. A modal will open where you'll be able to input the name of the API Key. Choose a name that'll help you remember where and how it's used. When you submit the form, a new modal will open with the actual API key token . For security reasons, it'll be shown only once . Copy and paste it somewhere safe before closing the modal. Delete an API Key \u00b6 If one of your API Key is not useful anymore, you can delete it by clicking on the Delete button in the list.","title":"API Keys"},{"location":"getting-started/api-keys/#api-keys","text":"This is where you'll see and manage the api keys of your workspace. What is an API key? An API key is a secret token that'll allow you to make authenticated requests to the Fief Admin API . It'll be useful if you need, for example, to manage tenants or clients programmatically from your own application. Keep it secret and safe An API key gives complete accesss to your workspace data. Keep it somewhere safe and don't share it with anyone.","title":"API Keys"},{"location":"getting-started/api-keys/#create-a-new-api-key","text":"To create a new API Key, click on the Create API Key button. A modal will open where you'll be able to input the name of the API Key. Choose a name that'll help you remember where and how it's used. When you submit the form, a new modal will open with the actual API key token . For security reasons, it'll be shown only once . Copy and paste it somewhere safe before closing the modal.","title":"Create a new API Key"},{"location":"getting-started/api-keys/#delete-an-api-key","text":"If one of your API Key is not useful anymore, you can delete it by clicking on the Delete button in the list.","title":"Delete an API Key"},{"location":"getting-started/clients/","text":"Clients \u00b6 This is where you'll see and manage the clients of your workspace. What is a client? A client is a central part of the OAuth2 protocol. It's the definition of an application authorized to request for access tokens and user information on Fief. In other words, your application will need one of those client to be able to authenticate users from your Fief workspace. Each client has a Client ID and a Client Secret. Those values are used during OAuth2 authentification to recognize the client. Each workspace comes with one client, tied to the default tenant . View client details \u00b6 If you click on one of the client in the list, you'll see its details on the right. Especially, you'll be able to copy its ID and Secret by using the clipboard buttons. Create a new client \u00b6 You can create a new client by clicking the Create Client button. A modal will open where you'll be able to input its name, if it's a first-party, its redirect URIs and its associated tenant. When should I create a new client? If you have several applications authenticating to your Fief workspace, you should consider creating new clients. Typically, if you have both a web and a mobile application, it's usually a good idea to have a client for each one. This way, it's easier to track down where the tokens come from and mitigates the risk of compromising data if one of the application has a security breach. Edit an existing client \u00b6 You can edit an existing client by opening its details and click on the Edit Client button. A modal will open where you'll be able to change its name, if it's a first-party and its redirect URIs First-party clients \u00b6 You probably noticed that your first client has a first-party badge. It means that this client is intended to be used by your own, official application. In this context, when users log in to your application, the traditional OAuth2 consent screen is bypassed . Since you are the developer of the application, it makes sense to not ask the user for their consent to use their data on the same application! For third-party applications, like developers from another company who want to integrate your API in their product, you'll provide them a client without this first-party flag. In this context, we want the user consent to be explicit. Redirect URIs \u00b6 During an OAuth2 authentication flow , after the user has successfully logged in, Fief will redirect them to your application with a temporary code. At that point, your application will use this temporary code to obtain a valid token. For security reasons, Fief won't allow the user to be redirected to any URI . Instead, you have to explicitly allow every URI you'll need in your applications. For HTTP URIs, they need to use the https scheme; http URL are not allowed. The only exception to this rule is localhost , which can be in http for local development purposes.","title":"Clients"},{"location":"getting-started/clients/#clients","text":"This is where you'll see and manage the clients of your workspace. What is a client? A client is a central part of the OAuth2 protocol. It's the definition of an application authorized to request for access tokens and user information on Fief. In other words, your application will need one of those client to be able to authenticate users from your Fief workspace. Each client has a Client ID and a Client Secret. Those values are used during OAuth2 authentification to recognize the client. Each workspace comes with one client, tied to the default tenant .","title":"Clients"},{"location":"getting-started/clients/#view-client-details","text":"If you click on one of the client in the list, you'll see its details on the right. Especially, you'll be able to copy its ID and Secret by using the clipboard buttons.","title":"View client details"},{"location":"getting-started/clients/#create-a-new-client","text":"You can create a new client by clicking the Create Client button. A modal will open where you'll be able to input its name, if it's a first-party, its redirect URIs and its associated tenant. When should I create a new client? If you have several applications authenticating to your Fief workspace, you should consider creating new clients. Typically, if you have both a web and a mobile application, it's usually a good idea to have a client for each one. This way, it's easier to track down where the tokens come from and mitigates the risk of compromising data if one of the application has a security breach.","title":"Create a new client"},{"location":"getting-started/clients/#edit-an-existing-client","text":"You can edit an existing client by opening its details and click on the Edit Client button. A modal will open where you'll be able to change its name, if it's a first-party and its redirect URIs","title":"Edit an existing client"},{"location":"getting-started/clients/#first-party-clients","text":"You probably noticed that your first client has a first-party badge. It means that this client is intended to be used by your own, official application. In this context, when users log in to your application, the traditional OAuth2 consent screen is bypassed . Since you are the developer of the application, it makes sense to not ask the user for their consent to use their data on the same application! For third-party applications, like developers from another company who want to integrate your API in their product, you'll provide them a client without this first-party flag. In this context, we want the user consent to be explicit.","title":"First-party clients"},{"location":"getting-started/clients/#redirect-uris","text":"During an OAuth2 authentication flow , after the user has successfully logged in, Fief will redirect them to your application with a temporary code. At that point, your application will use this temporary code to obtain a valid token. For security reasons, Fief won't allow the user to be redirected to any URI . Instead, you have to explicitly allow every URI you'll need in your applications. For HTTP URIs, they need to use the https scheme; http URL are not allowed. The only exception to this rule is localhost , which can be in http for local development purposes.","title":"Redirect URIs"},{"location":"getting-started/introduction/","text":"Introduction \u00b6 Fief is what is usually called an identity provider : it provides and secures user identities to external apps. To allow this, Fief implements the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol . Basically, it describes a secure way for a user to give access to its data to an external app. So, how does everything will fit together? In a nutshell, Fief will store everything about your users data (email address, hashed passwords...) and give you a simple way to authenticate them in your application. graph TD U((User)) A{Your application} subgraph FIEF [Fief] F[Fief API] FL[Login page] FD[(Fief database)] end U -- is not authenticated ----> FL U -- is authenticated ----> A A -- checks user identity on --> F FL -. redirects to .-> A F -- stores users on --> FD Let's get started! \u00b6 The first thing to do is to create your workspace!","title":"Introduction"},{"location":"getting-started/introduction/#introduction","text":"Fief is what is usually called an identity provider : it provides and secures user identities to external apps. To allow this, Fief implements the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol . Basically, it describes a secure way for a user to give access to its data to an external app. So, how does everything will fit together? In a nutshell, Fief will store everything about your users data (email address, hashed passwords...) and give you a simple way to authenticate them in your application. graph TD U((User)) A{Your application} subgraph FIEF [Fief] F[Fief API] FL[Login page] FD[(Fief database)] end U -- is not authenticated ----> FL U -- is authenticated ----> A A -- checks user identity on --> F FL -. redirects to .-> A F -- stores users on --> FD","title":"Introduction"},{"location":"getting-started/introduction/#lets-get-started","text":"The first thing to do is to create your workspace!","title":"Let's get started!"},{"location":"getting-started/oauth2/","text":"Understand OAuth2 \u00b6 Fief uses the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol to securely authenticate users . If you understand the basics of this protocol, you'll better understand how to integrate Fief to your own application. You probably already used OAuth2 before: whenever you use a button like Sign In with Google or Sign In with Facebook on a website, you actually authenticate yourself using the OAuth2 protocol! Authentication flow \u00b6 Schematically, a complete OAuth2 flow looks like this: sequenceDiagram actor U as User participant A as Your app participant F as Fief U->>A: Wants to login A->>U: Redirects to Fief login page U->>F: Authenticates on Fief F->>A: Redirects with a temporary code A->>F: Exchanges the temporary code F->>A: Generates a valid token A->>U: Answers with a valid session You see that we have three actors in this flow: The user Your application that needs to know the authenticated user Fief , which is able to authenticate users and provide their information This flow relies a lot on redirections: The user first tries to access your application. If they're not logged in, they are redirected to the Fief login page. On this login page, the user will input its credentials, typically an email address and a password to authenticate themself. At this point, we don't have a valid user session yet . In traditional applications, after a successful login, we do obtain a valid user session. However, in this context, the application needing the user session, your application, is not the same as the one that provides authentication, Fief. That's why we have an additional step: Fief redirects to your application with a temporary code, called the authorization code . This code is then used by your application to call the Fief API and obtain a valid token in exchange. Finally, your application can save this token somewhere to maintain the user session. The benefit of this approach is that your application never has access to the user credentials: the sensitive and difficult part is handled by Fief. There are other OAuth2 variants OAuth2 proposes several ways to achieve this kind of authentication flow. We showed here the authorization code grant , which is the most widely-used and the default in Fief. Scopes \u00b6 A central part in OAuth2 is the concept of scopes . Basically, it determines what the application will be able to do or not with the user data. For the user, this translates to the famous consent screen : it's a special page after a successful login telling them what the application wants to do with their data. Once the access token is generated, it'll be tied to this specific list of scopes the user has granted. In your application, you'll be able to limit some actions based on those scopes. As we said in introduction, we use the OpenID Connect protocol on top of OAuth2. With this protocol, we always have at least one scope, openid . It's a core scope giving access to the basic information of the user. First-party clients Since you'll use Fief to authenticate users on your own, official application, we introduced the concept of first-party clients. When a user logs in on a client configured as first-party, the consent screen is bypassed and every scopes asked are implicitly granted. You can read more about this in the dedicated section . Limitations In the future, you'll be able to create your own set of scopes in Fief. Access Token and ID Token \u00b6 After a successful authentication flow, your application will get two different tokens: an access token and an ID token . The first one, the access token , is a secret value that'll authenticate the user on your application. It's tied to a specific user and a list of scopes. On the other hand, the ID token is a value containing all the basic information about the authenticated user, like its email and other personal information. It'll be very useful in your application if you need for example to display the email of the current user. For security reasons, both of them have a limited lifetime . At some point, we'll need to make another OAuth2 authentication flow again to retrieve fresh tokens. Those are JWT The access token and the ID token are both generated as JSON Web Tokens (JWT). JWT is a widely-used standard to secure data contained in a standard JSON object. Typically, JWT are cryptographically signed . It means that your application is able to certify that the tokens you get are true and authentic tokens generated by Fief, and not forged by a malicious attacker. This is critical since we use those to authenticate users into your app. The technical details around this are a bit complex but you can read more about on the official JWT documentation .","title":"Understand OAuth2"},{"location":"getting-started/oauth2/#understand-oauth2","text":"Fief uses the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol to securely authenticate users . If you understand the basics of this protocol, you'll better understand how to integrate Fief to your own application. You probably already used OAuth2 before: whenever you use a button like Sign In with Google or Sign In with Facebook on a website, you actually authenticate yourself using the OAuth2 protocol!","title":"Understand OAuth2"},{"location":"getting-started/oauth2/#authentication-flow","text":"Schematically, a complete OAuth2 flow looks like this: sequenceDiagram actor U as User participant A as Your app participant F as Fief U->>A: Wants to login A->>U: Redirects to Fief login page U->>F: Authenticates on Fief F->>A: Redirects with a temporary code A->>F: Exchanges the temporary code F->>A: Generates a valid token A->>U: Answers with a valid session You see that we have three actors in this flow: The user Your application that needs to know the authenticated user Fief , which is able to authenticate users and provide their information This flow relies a lot on redirections: The user first tries to access your application. If they're not logged in, they are redirected to the Fief login page. On this login page, the user will input its credentials, typically an email address and a password to authenticate themself. At this point, we don't have a valid user session yet . In traditional applications, after a successful login, we do obtain a valid user session. However, in this context, the application needing the user session, your application, is not the same as the one that provides authentication, Fief. That's why we have an additional step: Fief redirects to your application with a temporary code, called the authorization code . This code is then used by your application to call the Fief API and obtain a valid token in exchange. Finally, your application can save this token somewhere to maintain the user session. The benefit of this approach is that your application never has access to the user credentials: the sensitive and difficult part is handled by Fief. There are other OAuth2 variants OAuth2 proposes several ways to achieve this kind of authentication flow. We showed here the authorization code grant , which is the most widely-used and the default in Fief.","title":"Authentication flow"},{"location":"getting-started/oauth2/#scopes","text":"A central part in OAuth2 is the concept of scopes . Basically, it determines what the application will be able to do or not with the user data. For the user, this translates to the famous consent screen : it's a special page after a successful login telling them what the application wants to do with their data. Once the access token is generated, it'll be tied to this specific list of scopes the user has granted. In your application, you'll be able to limit some actions based on those scopes. As we said in introduction, we use the OpenID Connect protocol on top of OAuth2. With this protocol, we always have at least one scope, openid . It's a core scope giving access to the basic information of the user. First-party clients Since you'll use Fief to authenticate users on your own, official application, we introduced the concept of first-party clients. When a user logs in on a client configured as first-party, the consent screen is bypassed and every scopes asked are implicitly granted. You can read more about this in the dedicated section . Limitations In the future, you'll be able to create your own set of scopes in Fief.","title":"Scopes"},{"location":"getting-started/oauth2/#access-token-and-id-token","text":"After a successful authentication flow, your application will get two different tokens: an access token and an ID token . The first one, the access token , is a secret value that'll authenticate the user on your application. It's tied to a specific user and a list of scopes. On the other hand, the ID token is a value containing all the basic information about the authenticated user, like its email and other personal information. It'll be very useful in your application if you need for example to display the email of the current user. For security reasons, both of them have a limited lifetime . At some point, we'll need to make another OAuth2 authentication flow again to retrieve fresh tokens. Those are JWT The access token and the ID token are both generated as JSON Web Tokens (JWT). JWT is a widely-used standard to secure data contained in a standard JSON object. Typically, JWT are cryptographically signed . It means that your application is able to certify that the tokens you get are true and authentic tokens generated by Fief, and not forged by a malicious attacker. This is critical since we use those to authenticate users into your app. The technical details around this are a bit complex but you can read more about on the official JWT documentation .","title":"Access Token and ID Token"},{"location":"getting-started/tenants/","text":"Tenants \u00b6 This is where you'll see and manage the tenants of your workspace. What is a tenant? A tenant is a sub-division of your workspace. Each client and user is tied to a specific tenant. This is mostly useful if you want to create a product sold in white-label where each of your client has its own space. It allows for example for a user to have several accounts with the same email address inside one workspace, but actually tied to different tenants. From a user point-of-view, this is a different application on which they login with different credentials. If you don't plan to do this, that's okay: you'll always use a single tenant in your workspace. Each workspace has at least one default tenant. Base URL \u00b6 Each tenant is tied to a base URL : each routes, like login or registration, will be derived from this base. When you integrate Fief in your application, you'll need this base URL. Each workspace has one default tenant with a base URL pointing to your root subdomain, like https://example.fief.dev . Other tenants gets a path prefix, like https://example.fief.dev/other-tenant . Tip You can copy the base URL directly using the clipboard button in the list. Limitation At the moment, new tenants can't be created from the admin dashboard.","title":"Tenants"},{"location":"getting-started/tenants/#tenants","text":"This is where you'll see and manage the tenants of your workspace. What is a tenant? A tenant is a sub-division of your workspace. Each client and user is tied to a specific tenant. This is mostly useful if you want to create a product sold in white-label where each of your client has its own space. It allows for example for a user to have several accounts with the same email address inside one workspace, but actually tied to different tenants. From a user point-of-view, this is a different application on which they login with different credentials. If you don't plan to do this, that's okay: you'll always use a single tenant in your workspace. Each workspace has at least one default tenant.","title":"Tenants"},{"location":"getting-started/tenants/#base-url","text":"Each tenant is tied to a base URL : each routes, like login or registration, will be derived from this base. When you integrate Fief in your application, you'll need this base URL. Each workspace has one default tenant with a base URL pointing to your root subdomain, like https://example.fief.dev . Other tenants gets a path prefix, like https://example.fief.dev/other-tenant . Tip You can copy the base URL directly using the clipboard button in the list. Limitation At the moment, new tenants can't be created from the admin dashboard.","title":"Base URL"},{"location":"getting-started/users/","text":"Users \u00b6 This is where you'll see and manage the users of your workspace. What is a user? A user is the fundamental part of your Fief workspace: it represents the actual user that'll have access to your application! We store basic information about the user, like its email address and hashed password and take care of verifying its credentials upon login. Every user is tied to a tenant . It means that an individual can have several user accounts on your workspace, with the same email address, but tied to a different tenant. Create a new user \u00b6 In some circumstances, you might need to create a user manually from the admin dashboard. You can do so by clicking on the Create User button. A modal will open where you'll be able to input its email address, password and associated tenant. Info User created that way will receive the welcome email, as if they registered themselves.","title":"Users"},{"location":"getting-started/users/#users","text":"This is where you'll see and manage the users of your workspace. What is a user? A user is the fundamental part of your Fief workspace: it represents the actual user that'll have access to your application! We store basic information about the user, like its email address and hashed password and take care of verifying its credentials upon login. Every user is tied to a tenant . It means that an individual can have several user accounts on your workspace, with the same email address, but tied to a different tenant.","title":"Users"},{"location":"getting-started/users/#create-a-new-user","text":"In some circumstances, you might need to create a user manually from the admin dashboard. You can do so by clicking on the Create User button. A modal will open where you'll be able to input its email address, password and associated tenant. Info User created that way will receive the welcome email, as if they registered themselves.","title":"Create a new user"},{"location":"getting-started/workspace/","text":"Create your workspace \u00b6 The easiest way to get started is to create your workspace on our official Fief instance . After having created your user account, you'll be guided through the creation of your workspace . What is a workspace? A workspace is a place where all your Fief data lives: configuration, users data, etc. Each workspace has its own subdomain reserved for you, like https://example.fief.dev . If you are working on several projects or companies, we recommend to create several workspaces to keep things organized. Step 1: name your workspace \u00b6 The first step is to name your workspace. Use a name describing your application or company: it'll be used to generate your workspace subdomain. For example, a workspace named Bretagne Duchy will be assigned to the subdomain https://bretagne-duchy.fief.dev . Step 2: select your type of database \u00b6 One of the great strength of Fief is that you can bring your own database to store your workspace data. This way, you keep in total control of your data. Of course, we also propose you to store your data on our performand and secure cloud database. Your choice! At this step, you can make the choice between the Fief cloud database or configure your own. For the sake of simplicity, we'll choose here the cloud database . If you want to bring your own database, we recommend you to read the dedicated section . Ready to go! \u00b6 That's it! At this point, everything is ready to create your workspace! After that, you'll be redirected to your admin dashboard, where you'll be able to manage your workspace.","title":"Create your workspace"},{"location":"getting-started/workspace/#create-your-workspace","text":"The easiest way to get started is to create your workspace on our official Fief instance . After having created your user account, you'll be guided through the creation of your workspace . What is a workspace? A workspace is a place where all your Fief data lives: configuration, users data, etc. Each workspace has its own subdomain reserved for you, like https://example.fief.dev . If you are working on several projects or companies, we recommend to create several workspaces to keep things organized.","title":"Create your workspace"},{"location":"getting-started/workspace/#step-1-name-your-workspace","text":"The first step is to name your workspace. Use a name describing your application or company: it'll be used to generate your workspace subdomain. For example, a workspace named Bretagne Duchy will be assigned to the subdomain https://bretagne-duchy.fief.dev .","title":"Step 1: name your workspace"},{"location":"getting-started/workspace/#step-2-select-your-type-of-database","text":"One of the great strength of Fief is that you can bring your own database to store your workspace data. This way, you keep in total control of your data. Of course, we also propose you to store your data on our performand and secure cloud database. Your choice! At this step, you can make the choice between the Fief cloud database or configure your own. For the sake of simplicity, we'll choose here the cloud database . If you want to bring your own database, we recommend you to read the dedicated section .","title":"Step 2: select your type of database"},{"location":"getting-started/workspace/#ready-to-go","text":"That's it! At this point, everything is ready to create your workspace! After that, you'll be redirected to your admin dashboard, where you'll be able to manage your workspace.","title":"Ready to go!"},{"location":"going-further/byod/","text":"Bring your own database \u00b6","title":"Bring your own database"},{"location":"going-further/byod/#bring-your-own-database","text":"","title":"Bring your own database"},{"location":"going-further/id-token-encryption/","text":"ID Token encryption \u00b6","title":"ID Token encryption"},{"location":"going-further/id-token-encryption/#id-token-encryption","text":"","title":"ID Token encryption"},{"location":"integrate/javascript/","text":"\ud83d\udfe8 JavaScript \u00b6","title":"\ud83d\udfe8 JavaScript"},{"location":"integrate/javascript/#javascript","text":"","title":"\ud83d\udfe8 JavaScript"},{"location":"integrate/nodejs/","text":"\ud83d\udfe2 NodeJS \u00b6","title":"\ud83d\udfe2 NodeJS"},{"location":"integrate/nodejs/#nodejs","text":"","title":"\ud83d\udfe2 NodeJS"},{"location":"integrate/python/","text":"Python \u00b6 We provide an official client for Python. You can install it with pip : pip install fief-client Create a Fief client \u00b6 The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Base URL of your Fief tenant You can find it in the admin dashboard, in the Tenants list. More info ID of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Secret of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Avoid to hardcode your secrets in your code It's usually not recommended to hardcode secrets like Client ID and Secret in your code like this. If your code gets published on the web, for example on GitHub, the security of your workspace would be compromised. Besides, it'll be harder if you need to deploy on several environments, like a staging or testing one, in addition to your production environment. A standard and widely-used approach is to use environment variables . Async support For asyncio enthusiasts, we also provide a FiefAsync class with the same methods. Perform an OAuth2 flow manually \u00b6 The simple script below shows you how to authenticate with OAuth2 \"manually\". The goal is to show you how to use the client. You'll then be able to integrate it in your own project with your framework and stack. The first step is to generate an authorization URL , which is an URL on the Fief server that'll ask you for your email address and password. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Then, we make the script prompt for the authorization code . client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) This temporary code is generated by Fief upon successful login and can be used to obtain valid tokens. Fief returns both an access token and an ID token , which contains information about the user. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Test it \u00b6 You can run this script from a command line: python client.py You'll get the following output: Open this URL in your browser: https://example.fief.dev/authorize?response_type=code&client_id=YOUR_CLIENT_ID&redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fcallback&scope=openid Paste the callback code: You can copy and paste this URL manually in your browser . You'll be redirected to a Fief login page. Upon successful login, Fief will redirect to the redirect URL you defined above, including a query parameter named code . It'll look like this: http://localhost:8000/redirect?code=wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Your browser will probably show an error at this point In this simple implementation, we don't have a web server running on our local machine, so the browser won't be able to open the redirect URL. It's not a problem: what we care about is retrieving the authorization code by hand. Copy the code value, get back to the command line where the script is running and paste it. You'll get the following output: Paste the callback code: wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Tokens: {'access_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInNjb3BlIjoib3BlbmlkIiwic3ViIjoiYTM4NDZjYzEtN2MwOC00Mzg5LThjOGUtYzBlNzlmNzA3NWZlIn0.R5JnZW9Vq6lWai-FZcqsihYxmtFRbIjZ7D0Ck9XAG0d2YnQQ7ms3bUwtXEAnLhos4C3paGDa0PzQRtXSAx4IH85ZdeVJoBk9GrOj1ZV7E6dtZZSZlvtY2msMeXFC9gNg-A86R9ZU_T0PoROof0u1eJHYVlmo_dv2fodyNqkDB8V6HK3vqf7jaqNQtk8Fg6eHKhwb-3bAtjb5cpWAAWhMSrHZzTWIYUvYsvwAas5ihgenv3UOkpcl_p7b7G9SDhGE5abPQQ7lvyfhYZE7CV1DzVRU6UL4N0D2l4uI3RJNOQoECvltfo2etYzp5viwAwvg9LUS3466Ra1i8beBKXsPFQ', 'id_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZW1haWwiOiJmcmFuY29pcyt0ZXN0QGZpZWYuZGV2IiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInN1YiI6ImEzODQ2Y2MxLTdjMDgtNDM4OS04YzhlLWMwZTc5ZjcwNzVmZSIsInRlbmFudF9pZCI6IjcwNDEzNWI2LTRiZmQtNGM1NS04MDkwLWM2MzhhNmJhNTNhMiJ9.ULQy7TlgF5_oQwwgA6ydTahTYE31obr4F3olJy-mgyPw67XstoJLM1VwUNawzyz2Iu2QDmgcBrH3OMVfgCkBAFk2sp-QQIDr9arIF1QXNKG65El3zgPQ5-niTTsIuAkemyjNGcpdrcN2b9FaeodzauO5eOjno60h5dTBbcLnqv00V-Jv6sq8lB8_o5JXHKWUoZZA2VFEDox9MXfhDqrvyHcitsIRWIy7XhILKcZ-JG_AMcXnuDcyMnsoy91-gJznvMk7_ty9eNWs8Cm0ZhK3nMqEKML4tXIREmIN-vYUGDtbDWX3O45N98ovu9gJi9S3aVOh-gZQsnwauJmlW82ZQQ', 'token_type': 'bearer', 'expires_in': 3600} Userinfo: {'aud': ['YOUR_CLIENT_ID'], 'azp': 'YOUR_CLIENT_ID', 'email': 'anne@bretagne.duchy', 'exp': 1648050423, 'iat': 1648046823, 'iss': 'https://example.fief.dev', 'sub': 'a3846cc1-7c08-4389-8c8e-c0e79f7075fe', 'tenant_id': '704135b6-4bfd-4c55-8090-c638a6ba53a2'} As you can see, we obtained a first dictionary tokens containing an access token, an ID token and other standard OAuth2 information. The second variable, userinfo , is a dictionary with the user data. It's actually the information contained in the ID token that the client decoded for you. What's next? \u00b6 You have the fundamental basics for performing an OAuth2 authentication with the Fief Python client. To help you further, we provide you helpers and examples for popular Python frameworks like Flask or FastAPI. Integrate with FastAPI Integrate with Flask Reference \u00b6 auth_url \u00b6 Returns an authorization URL. Parameters redirect_uri: str : Your callback URI where the user will be redirected after the service prompt. state: str = None : Optional string that will be returned back in the callback parameters to allow you to retrieve state information. scope: Optional[List[str]] = None : Optional list of scopes to ask for. extras_params: Optional[Dict[str, Any]] = None : Optional dictionary containing specific parameters. Example auth_url = fief . auth_url ( \"http://localhost:8000/callback\" , scope = [ \"openid\" ]) auth_callback \u00b6 Returns valid tokens and user info in exchange of an authorization code. Parameters code: str : The authorization code. redirect_uri: str : The exact same redirect_uri you passed to the authorization URL. Example tokens , userinfo = fief . auth_callback ( \"CODE\" , \"http://localhost:8000/callback\" ) auth_refresh_token \u00b6 Returns fresh tokens and user info in exchange of a refresh token. Parameters refresh_token: str : A valid refresh token. scope: Optional[List[str]] = None : Optional list of scopes to ask for. If not provided, the access token will share the same list of scopes as requested the first time. Otherwise, it should be a subset of the original list of scopes. Example tokens , userinfo = fief . auth_refresh_token ( \"REFRESH_TOKEN\" ) validate_access_token \u00b6 Checks if an access token is valid and optionally that it has a required list of scopes. Parameters access_token: str : The access token to validate. required_scope: Optional[List[str]] = None : Optional list of scopes to check for. Example from fief_client import FiefAccessTokenInvalid , FiefAccessTokenExpired , FiefAccessTokenMissingScope try : access_token_info = fief . validate_access_token ( \"ACCESS_TOKEN\" , required_scope = [ \"required_scope\" ]) except FiefAccessTokenInvalid : print ( \"Invalid access token\" ) except FiefAccessTokenExpired : print ( \"Expired access token\" ) except FiefAccessTokenMissingScope : print ( \"Missing required scope\" ) print ( access_token_info ) # {\"id\": \"USER_ID\", \"scope\": [\"openid\", \"required_scope\"], \"access_token\": \"ACCESS_TOKEN\"} userinfo \u00b6 Returns fresh user information from the Fief API using a valid access token. Parameters access_token: str : A valid access token Example userinfo = fief . userinfo ( \"ACCESS_TOKEN\" )","title":"Python"},{"location":"integrate/python/#python","text":"We provide an official client for Python. You can install it with pip : pip install fief-client","title":"Python"},{"location":"integrate/python/#create-a-fief-client","text":"The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Base URL of your Fief tenant You can find it in the admin dashboard, in the Tenants list. More info ID of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Secret of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Avoid to hardcode your secrets in your code It's usually not recommended to hardcode secrets like Client ID and Secret in your code like this. If your code gets published on the web, for example on GitHub, the security of your workspace would be compromised. Besides, it'll be harder if you need to deploy on several environments, like a staging or testing one, in addition to your production environment. A standard and widely-used approach is to use environment variables . Async support For asyncio enthusiasts, we also provide a FiefAsync class with the same methods.","title":"Create a Fief client"},{"location":"integrate/python/#perform-an-oauth2-flow-manually","text":"The simple script below shows you how to authenticate with OAuth2 \"manually\". The goal is to show you how to use the client. You'll then be able to integrate it in your own project with your framework and stack. The first step is to generate an authorization URL , which is an URL on the Fief server that'll ask you for your email address and password. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Then, we make the script prompt for the authorization code . client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) This temporary code is generated by Fief upon successful login and can be used to obtain valid tokens. Fief returns both an access token and an ID token , which contains information about the user. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" )","title":"Perform an OAuth2 flow manually"},{"location":"integrate/python/#test-it","text":"You can run this script from a command line: python client.py You'll get the following output: Open this URL in your browser: https://example.fief.dev/authorize?response_type=code&client_id=YOUR_CLIENT_ID&redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fcallback&scope=openid Paste the callback code: You can copy and paste this URL manually in your browser . You'll be redirected to a Fief login page. Upon successful login, Fief will redirect to the redirect URL you defined above, including a query parameter named code . It'll look like this: http://localhost:8000/redirect?code=wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Your browser will probably show an error at this point In this simple implementation, we don't have a web server running on our local machine, so the browser won't be able to open the redirect URL. It's not a problem: what we care about is retrieving the authorization code by hand. Copy the code value, get back to the command line where the script is running and paste it. You'll get the following output: Paste the callback code: wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Tokens: {'access_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInNjb3BlIjoib3BlbmlkIiwic3ViIjoiYTM4NDZjYzEtN2MwOC00Mzg5LThjOGUtYzBlNzlmNzA3NWZlIn0.R5JnZW9Vq6lWai-FZcqsihYxmtFRbIjZ7D0Ck9XAG0d2YnQQ7ms3bUwtXEAnLhos4C3paGDa0PzQRtXSAx4IH85ZdeVJoBk9GrOj1ZV7E6dtZZSZlvtY2msMeXFC9gNg-A86R9ZU_T0PoROof0u1eJHYVlmo_dv2fodyNqkDB8V6HK3vqf7jaqNQtk8Fg6eHKhwb-3bAtjb5cpWAAWhMSrHZzTWIYUvYsvwAas5ihgenv3UOkpcl_p7b7G9SDhGE5abPQQ7lvyfhYZE7CV1DzVRU6UL4N0D2l4uI3RJNOQoECvltfo2etYzp5viwAwvg9LUS3466Ra1i8beBKXsPFQ', 'id_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZW1haWwiOiJmcmFuY29pcyt0ZXN0QGZpZWYuZGV2IiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInN1YiI6ImEzODQ2Y2MxLTdjMDgtNDM4OS04YzhlLWMwZTc5ZjcwNzVmZSIsInRlbmFudF9pZCI6IjcwNDEzNWI2LTRiZmQtNGM1NS04MDkwLWM2MzhhNmJhNTNhMiJ9.ULQy7TlgF5_oQwwgA6ydTahTYE31obr4F3olJy-mgyPw67XstoJLM1VwUNawzyz2Iu2QDmgcBrH3OMVfgCkBAFk2sp-QQIDr9arIF1QXNKG65El3zgPQ5-niTTsIuAkemyjNGcpdrcN2b9FaeodzauO5eOjno60h5dTBbcLnqv00V-Jv6sq8lB8_o5JXHKWUoZZA2VFEDox9MXfhDqrvyHcitsIRWIy7XhILKcZ-JG_AMcXnuDcyMnsoy91-gJznvMk7_ty9eNWs8Cm0ZhK3nMqEKML4tXIREmIN-vYUGDtbDWX3O45N98ovu9gJi9S3aVOh-gZQsnwauJmlW82ZQQ', 'token_type': 'bearer', 'expires_in': 3600} Userinfo: {'aud': ['YOUR_CLIENT_ID'], 'azp': 'YOUR_CLIENT_ID', 'email': 'anne@bretagne.duchy', 'exp': 1648050423, 'iat': 1648046823, 'iss': 'https://example.fief.dev', 'sub': 'a3846cc1-7c08-4389-8c8e-c0e79f7075fe', 'tenant_id': '704135b6-4bfd-4c55-8090-c638a6ba53a2'} As you can see, we obtained a first dictionary tokens containing an access token, an ID token and other standard OAuth2 information. The second variable, userinfo , is a dictionary with the user data. It's actually the information contained in the ID token that the client decoded for you.","title":"Test it"},{"location":"integrate/python/#whats-next","text":"You have the fundamental basics for performing an OAuth2 authentication with the Fief Python client. To help you further, we provide you helpers and examples for popular Python frameworks like Flask or FastAPI. Integrate with FastAPI Integrate with Flask","title":"What's next?"},{"location":"integrate/python/#reference","text":"","title":"Reference"},{"location":"integrate/python/#auth_url","text":"Returns an authorization URL. Parameters redirect_uri: str : Your callback URI where the user will be redirected after the service prompt. state: str = None : Optional string that will be returned back in the callback parameters to allow you to retrieve state information. scope: Optional[List[str]] = None : Optional list of scopes to ask for. extras_params: Optional[Dict[str, Any]] = None : Optional dictionary containing specific parameters. Example auth_url = fief . auth_url ( \"http://localhost:8000/callback\" , scope = [ \"openid\" ])","title":"auth_url"},{"location":"integrate/python/#auth_callback","text":"Returns valid tokens and user info in exchange of an authorization code. Parameters code: str : The authorization code. redirect_uri: str : The exact same redirect_uri you passed to the authorization URL. Example tokens , userinfo = fief . auth_callback ( \"CODE\" , \"http://localhost:8000/callback\" )","title":"auth_callback"},{"location":"integrate/python/#auth_refresh_token","text":"Returns fresh tokens and user info in exchange of a refresh token. Parameters refresh_token: str : A valid refresh token. scope: Optional[List[str]] = None : Optional list of scopes to ask for. If not provided, the access token will share the same list of scopes as requested the first time. Otherwise, it should be a subset of the original list of scopes. Example tokens , userinfo = fief . auth_refresh_token ( \"REFRESH_TOKEN\" )","title":"auth_refresh_token"},{"location":"integrate/python/#validate_access_token","text":"Checks if an access token is valid and optionally that it has a required list of scopes. Parameters access_token: str : The access token to validate. required_scope: Optional[List[str]] = None : Optional list of scopes to check for. Example from fief_client import FiefAccessTokenInvalid , FiefAccessTokenExpired , FiefAccessTokenMissingScope try : access_token_info = fief . validate_access_token ( \"ACCESS_TOKEN\" , required_scope = [ \"required_scope\" ]) except FiefAccessTokenInvalid : print ( \"Invalid access token\" ) except FiefAccessTokenExpired : print ( \"Expired access token\" ) except FiefAccessTokenMissingScope : print ( \"Missing required scope\" ) print ( access_token_info ) # {\"id\": \"USER_ID\", \"scope\": [\"openid\", \"required_scope\"], \"access_token\": \"ACCESS_TOKEN\"}","title":"validate_access_token"},{"location":"integrate/python/#userinfo","text":"Returns fresh user information from the Fief API using a valid access token. Parameters access_token: str : A valid access token Example userinfo = fief . userinfo ( \"ACCESS_TOKEN\" )","title":"userinfo"},{"location":"integrate/python/fastapi/","text":"FastAPI \u00b6 FastAPI is one of the fastest-growing Python web framework. It features impressive performance and top-notch developer experience. Actually, the Fief server itself is implemented with FastAPI! The Fief Python client provides tools to help you integrate Fief authentication in your FastAPI project. Let's see how to use them! Install the client \u00b6 Install the Fief client with the optional FastAPI dependencies: pip install \"fief-client[fastapi]\" API example \u00b6 This is for you if... Your FastAPI backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. In this first example, we'll leverage the interactive documentation generated by FastAPI to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( # (2)! \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) # (3)! app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ()), # (4)! ): return access_token_info Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Notice here that we use the FiefAsync class. FastAPI being an ASGI framework, it's always nice to take advantage of asyncio capabilities. OpenAPI security scheme FastAPI uses those security schemes to generate an interactive documentation showing the right interface to authenticate with the API. We use here a standard OAuth2 interface. Fief helper for FastAPI This is the helper doing the tedious work for you with FastAPI. All it needs is an instance of the Fief client and the scheme. current_user dependency This is where the magic happens: in pure FastAPI style, FiefAuth gives you a current_user dependency to check for the access token and optionally for required scopes. If everything goes well, you'll get a dictionary containing the ID of the user, the list of allowed scopes and the raw access token. And that's about it! Test it \u00b6 You can run this example just like you would do for any FastAPI app: uvicorn app:app Open http://localhost:8000/docs to access the interactive documentation. Let's try first the /user endpoint: We get an 401 error! That's expected: we are not authenticated yet ! Let's fix that: click on the Authorize button to start the authentication process. You'll need to provide your client ID and secret and select the scopes. Click on the Authorize button: you are redirected to the Fief login page. Upon successful login, you will be redirected back to the interactive documentation: a valid access token has been generated! You can now try the /user endpoint to check the result: Notice how the interactive documentation passed the access token in the Authorization header of the request! Besides, the response does contain the user ID, the list of allowed scopes and the access token itself. Checking for scopes \u00b6 Building on the previous example, you can make your endpoint requires the access token to be granted a list of scopes . Simply add this list of scopes as a parameter of the current_user dependency. app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ([ \"openid\" , \"required_scope\" ]) ), ): return access_token_info If one of the required scope is missing on the access token, a 403 Forbidden error will automatically be returned. Web application example \u00b6 This is for you if... Your FastAPI backend will render HTML pages. Your application is intended to be used in a browser. The examples we showed previously are working well in a pure REST API context: a frontend, like the interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application, where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py from datetime import datetime from fastapi import Depends , FastAPI , HTTPException , Query , Request , Response , status from fastapi.responses import HTMLResponse , RedirectResponse from fastapi.security import APIKeyCookie from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth class CustomFiefAuth ( FiefAuth ): # (1)! client : FiefAsync async def get_unauthorized_response ( self , request : Request , response : Response ): redirect_uri = request . url_for ( \"auth_callback\" ) # (2)! auth_url = await self . client . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (3)! raise HTTPException ( status_code = status . HTTP_307_TEMPORARY_REDIRECT , # (4)! headers = { \"Location\" : auth_url }, ) fief = FiefAsync ( # (5)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) SESSION_COOKIE_NAME = \"user_session\" scheme = APIKeyCookie ( name = SESSION_COOKIE_NAME , auto_error = False ) # (6)! auth = CustomFiefAuth ( fief , scheme ) # (7)! app = FastAPI () @app . get ( \"/auth-callback\" , name = \"auth_callback\" ) # (8)! async def auth_callback ( request : Request , response : Response , code : str = Query ( ... )): redirect_uri = request . url_for ( \"auth_callback\" ) tokens , _ = await fief . auth_callback ( code , redirect_uri ) # (9)! response = RedirectResponse ( request . url_for ( \"protected\" )) # (10)! response . set_cookie ( # (11)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (12)! secure = False , # \u274c Set this to `True` in production (13)! ) return response @app . get ( \"/protected\" , name = \"protected\" ) async def protected ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ()), # (14)! ): return HTMLResponse ( f \"<h1>You are authenticated. Your user ID is { access_token_info [ 'id' ] } </h1>\" ) We customize the FiefAuth helper to fit our needs The base class is implemented with an API scenario in mind. Nevertheless, it's designed in a way you can customize its behavior when the user is not authenticated or has not the required scope. That's what'll do with the get_unauthorized_response . We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server Thanks to the auth_url method on the Fief client, we can automatically generate the authorization URL on the Fief server. We build a redirect response By setting a status code in the 3XX range, we tell the browser that it should redirect the user to another URL, specified in the Location header. You can read more about HTTP redirections on the MDN documentation . This doesn't change from the previous example The FiefAsync client is always at the heart of the integration \ud83d\ude09 We use a scheme expecting a cookie Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use a dedicated scheme for that. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. Besides, we set the auto_error argument to False . It tells FastAPI user to bypass its built-in error response if the cookie is not present: we have our own logic to handle this. We use our custom CustomFiefAuth class Of course, now that we overloaded the behavior of this helper class, we shouldn't forget to actually use it! We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. Notice that we set its name parameter: this is how we can generate its URL automatically with the request.url_for method. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. Use the current_user dependency as usual This doesn't change from the previous example. The dependency will check if the cookie is available in the request and proceed if everything goes well. Otherwise, our custom get_unauthorized_response will be called and the user will be redirected to the Fief login page. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.","title":"FastAPI"},{"location":"integrate/python/fastapi/#fastapi","text":"FastAPI is one of the fastest-growing Python web framework. It features impressive performance and top-notch developer experience. Actually, the Fief server itself is implemented with FastAPI! The Fief Python client provides tools to help you integrate Fief authentication in your FastAPI project. Let's see how to use them!","title":"FastAPI"},{"location":"integrate/python/fastapi/#install-the-client","text":"Install the Fief client with the optional FastAPI dependencies: pip install \"fief-client[fastapi]\"","title":"Install the client"},{"location":"integrate/python/fastapi/#api-example","text":"This is for you if... Your FastAPI backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. In this first example, we'll leverage the interactive documentation generated by FastAPI to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( # (2)! \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) # (3)! app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ()), # (4)! ): return access_token_info Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Notice here that we use the FiefAsync class. FastAPI being an ASGI framework, it's always nice to take advantage of asyncio capabilities. OpenAPI security scheme FastAPI uses those security schemes to generate an interactive documentation showing the right interface to authenticate with the API. We use here a standard OAuth2 interface. Fief helper for FastAPI This is the helper doing the tedious work for you with FastAPI. All it needs is an instance of the Fief client and the scheme. current_user dependency This is where the magic happens: in pure FastAPI style, FiefAuth gives you a current_user dependency to check for the access token and optionally for required scopes. If everything goes well, you'll get a dictionary containing the ID of the user, the list of allowed scopes and the raw access token. And that's about it!","title":"API example"},{"location":"integrate/python/fastapi/#test-it","text":"You can run this example just like you would do for any FastAPI app: uvicorn app:app Open http://localhost:8000/docs to access the interactive documentation. Let's try first the /user endpoint: We get an 401 error! That's expected: we are not authenticated yet ! Let's fix that: click on the Authorize button to start the authentication process. You'll need to provide your client ID and secret and select the scopes. Click on the Authorize button: you are redirected to the Fief login page. Upon successful login, you will be redirected back to the interactive documentation: a valid access token has been generated! You can now try the /user endpoint to check the result: Notice how the interactive documentation passed the access token in the Authorization header of the request! Besides, the response does contain the user ID, the list of allowed scopes and the access token itself.","title":"Test it"},{"location":"integrate/python/fastapi/#checking-for-scopes","text":"Building on the previous example, you can make your endpoint requires the access token to be granted a list of scopes . Simply add this list of scopes as a parameter of the current_user dependency. app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ([ \"openid\" , \"required_scope\" ]) ), ): return access_token_info If one of the required scope is missing on the access token, a 403 Forbidden error will automatically be returned.","title":"Checking for scopes"},{"location":"integrate/python/fastapi/#web-application-example","text":"This is for you if... Your FastAPI backend will render HTML pages. Your application is intended to be used in a browser. The examples we showed previously are working well in a pure REST API context: a frontend, like the interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application, where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py from datetime import datetime from fastapi import Depends , FastAPI , HTTPException , Query , Request , Response , status from fastapi.responses import HTMLResponse , RedirectResponse from fastapi.security import APIKeyCookie from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth class CustomFiefAuth ( FiefAuth ): # (1)! client : FiefAsync async def get_unauthorized_response ( self , request : Request , response : Response ): redirect_uri = request . url_for ( \"auth_callback\" ) # (2)! auth_url = await self . client . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (3)! raise HTTPException ( status_code = status . HTTP_307_TEMPORARY_REDIRECT , # (4)! headers = { \"Location\" : auth_url }, ) fief = FiefAsync ( # (5)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) SESSION_COOKIE_NAME = \"user_session\" scheme = APIKeyCookie ( name = SESSION_COOKIE_NAME , auto_error = False ) # (6)! auth = CustomFiefAuth ( fief , scheme ) # (7)! app = FastAPI () @app . get ( \"/auth-callback\" , name = \"auth_callback\" ) # (8)! async def auth_callback ( request : Request , response : Response , code : str = Query ( ... )): redirect_uri = request . url_for ( \"auth_callback\" ) tokens , _ = await fief . auth_callback ( code , redirect_uri ) # (9)! response = RedirectResponse ( request . url_for ( \"protected\" )) # (10)! response . set_cookie ( # (11)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (12)! secure = False , # \u274c Set this to `True` in production (13)! ) return response @app . get ( \"/protected\" , name = \"protected\" ) async def protected ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ()), # (14)! ): return HTMLResponse ( f \"<h1>You are authenticated. Your user ID is { access_token_info [ 'id' ] } </h1>\" ) We customize the FiefAuth helper to fit our needs The base class is implemented with an API scenario in mind. Nevertheless, it's designed in a way you can customize its behavior when the user is not authenticated or has not the required scope. That's what'll do with the get_unauthorized_response . We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server Thanks to the auth_url method on the Fief client, we can automatically generate the authorization URL on the Fief server. We build a redirect response By setting a status code in the 3XX range, we tell the browser that it should redirect the user to another URL, specified in the Location header. You can read more about HTTP redirections on the MDN documentation . This doesn't change from the previous example The FiefAsync client is always at the heart of the integration \ud83d\ude09 We use a scheme expecting a cookie Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use a dedicated scheme for that. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. Besides, we set the auto_error argument to False . It tells FastAPI user to bypass its built-in error response if the cookie is not present: we have our own logic to handle this. We use our custom CustomFiefAuth class Of course, now that we overloaded the behavior of this helper class, we shouldn't forget to actually use it! We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. Notice that we set its name parameter: this is how we can generate its URL automatically with the request.url_for method. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. Use the current_user dependency as usual This doesn't change from the previous example. The dependency will check if the cookie is available in the request and proceed if everything goes well. Otherwise, our custom get_unauthorized_response will be called and the user will be redirected to the Fief login page. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.","title":"Web application example"},{"location":"integrate/python/flask/","text":"Flask \u00b6 Flask is probably the most popular Python web framework. The Fief Python client provides tools to help you integrate Fief authentication in your Flask project. Let's see how to use them! Install the client \u00b6 Install the Fief client with the optional Flask dependencies: pip install \"fief-client[flask]\" API example \u00b6 This is for you if... Your Flask backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. In this first example, we won't implement routes to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fief_client import Fief from fief_client.integrations.flask import ( FiefAuth , FiefAuthForbidden , FiefAuthUnauthorized , get_authorization_scheme_token , ) from flask import Flask , g fief = Fief ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) auth = FiefAuth ( fief , get_authorization_scheme_token ()) # (2)! app = Flask ( __name__ ) @app . errorhandler ( FiefAuthUnauthorized ) # (3)! def fief_unauthorized_error ( e ): return \"\" , 401 @app . errorhandler ( FiefAuthForbidden ) # (4)! def fief_forbidden_error ( e ): return \"\" , 403 @app . get ( \"/user\" ) @auth . current_user () # (5)! def get_user (): return g . user # (6)! @app . get ( \"/user-scope\" ) @auth . current_user ( scope = [ \"openid\" , \"required_scope\" ]) # (7)! def get_user_scope (): return g . user Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Fief helper for Flask This is the helper doing the tedious work for you with Flask. It first needs an instance of the Fief client we created above and a function retrieving the access token from the Flask request . It's a simple function which can use the global request object to retrieve the access token. For convenience, we provide two of them: get_authorization_scheme_token and get_cookie . Error handler for FiefAuthUnauthorized When a protected route is called without a valid access token, the Fief helper will raise the FiefAuthUnauthorized . By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 401 status code. Error handler for FiefAuthForbidden When a request is made with a valid access token but without the required scope, the Fief helper will raise the FiefAuthForbidden . By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 403 status code. current_user decorator This is where the magic happens: FiefAuth gives you a current_user decorator to check for the access token and optionally for required scopes. If everything goes well, the route logic will be executed. user dictionary is available in g When a valid access token is found in the request, the current_user decorator will automatically add the user property to the global g application context of Flask . This user property is a dictionary containing the ID of the user, the list of allowed scopes and the raw access token. Check for scopes The current_user decorator accepts an optional scope argument where you can list the scope required to access this route. If the access token doesn't have the required scope, the FiefAuthForbidden is raised. And that's about it! Web application example \u00b6 This is for you if... Your Flask backend will render HTML pages. Your application is intended to be used in a browser. The examples we showed previously are working well in a pure REST API context: a frontend, like the interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application, where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py from datetime import datetime from fief_client import Fief from fief_client.integrations.flask import ( FiefAuth , FiefAuthForbidden , FiefAuthUnauthorized , get_cookie , ) from flask import Flask , g , redirect , request , url_for SESSION_COOKIE_NAME = \"user_session\" fief = Fief ( # (1)! \"https://example.fief.dev\" , \"DOIhj_72Ha9rYh9uDgndSu62EXJuFfQ5lkkx1-ksUIo\" , \"WwOOiLopc5m_d_sjKk563oZDnbJDCWjJVmxkX1LffaQ\" , ) auth = FiefAuth ( fief , get_cookie ( SESSION_COOKIE_NAME )) # (2)! app = Flask ( __name__ ) @app . errorhandler ( FiefAuthUnauthorized ) # (3)! def fief_unauthorized_error ( e ): redirect_uri = url_for ( \"auth_callback\" , _external = True ) # (4)! auth_url = fief . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (5)! return redirect ( auth_url ) # (6)! @app . errorhandler ( FiefAuthForbidden ) def fief_forbidden_error ( e ): return \"\" , 403 @app . get ( \"/auth-callback\" ) # (7)! def auth_callback (): redirect_uri = url_for ( \"auth_callback\" , _external = True ) code = request . args [ \"code\" ] tokens , _ = fief . auth_callback ( code , redirect_uri ) # (8)! response = redirect ( url_for ( \"protected\" )) # (9)! response . set_cookie ( # (10)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (11)! secure = False , # \u274c Set this to `True` in production (12)! ) return response @app . get ( \"/protected\" ) @auth . current_user () # (13)! def protected (): user = g . user return f \"<h1>You are authenticated. Your user ID is { user [ 'id' ] } </h1>\" This doesn't change from the previous example The Fief client is always at the heart of the integration \ud83d\ude09 We use a cookie getter Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use the get_cookie getter. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. We change the error handler for FiefAuthUnauthorized This time, we'll generate a redirect response so the user can login on Fief. We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server Thanks to the auth_url method on the Fief client, we can automatically generate the authorization URL on the Fief server. We build a redirect response We redirect the user to the Fief authorization URL. We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. Use the current_user decorator as usual This doesn't change from the previous example. The dependency will check if the cookie is available in the request and proceed if everything goes well. Otherwise, an FiefAuthUnauthorized error will be raised and the user will be redirected to the Fief login page. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.","title":"Flask"},{"location":"integrate/python/flask/#flask","text":"Flask is probably the most popular Python web framework. The Fief Python client provides tools to help you integrate Fief authentication in your Flask project. Let's see how to use them!","title":"Flask"},{"location":"integrate/python/flask/#install-the-client","text":"Install the Fief client with the optional Flask dependencies: pip install \"fief-client[flask]\"","title":"Install the client"},{"location":"integrate/python/flask/#api-example","text":"This is for you if... Your Flask backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. In this first example, we won't implement routes to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fief_client import Fief from fief_client.integrations.flask import ( FiefAuth , FiefAuthForbidden , FiefAuthUnauthorized , get_authorization_scheme_token , ) from flask import Flask , g fief = Fief ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) auth = FiefAuth ( fief , get_authorization_scheme_token ()) # (2)! app = Flask ( __name__ ) @app . errorhandler ( FiefAuthUnauthorized ) # (3)! def fief_unauthorized_error ( e ): return \"\" , 401 @app . errorhandler ( FiefAuthForbidden ) # (4)! def fief_forbidden_error ( e ): return \"\" , 403 @app . get ( \"/user\" ) @auth . current_user () # (5)! def get_user (): return g . user # (6)! @app . get ( \"/user-scope\" ) @auth . current_user ( scope = [ \"openid\" , \"required_scope\" ]) # (7)! def get_user_scope (): return g . user Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Fief helper for Flask This is the helper doing the tedious work for you with Flask. It first needs an instance of the Fief client we created above and a function retrieving the access token from the Flask request . It's a simple function which can use the global request object to retrieve the access token. For convenience, we provide two of them: get_authorization_scheme_token and get_cookie . Error handler for FiefAuthUnauthorized When a protected route is called without a valid access token, the Fief helper will raise the FiefAuthUnauthorized . By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 401 status code. Error handler for FiefAuthForbidden When a request is made with a valid access token but without the required scope, the Fief helper will raise the FiefAuthForbidden . By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 403 status code. current_user decorator This is where the magic happens: FiefAuth gives you a current_user decorator to check for the access token and optionally for required scopes. If everything goes well, the route logic will be executed. user dictionary is available in g When a valid access token is found in the request, the current_user decorator will automatically add the user property to the global g application context of Flask . This user property is a dictionary containing the ID of the user, the list of allowed scopes and the raw access token. Check for scopes The current_user decorator accepts an optional scope argument where you can list the scope required to access this route. If the access token doesn't have the required scope, the FiefAuthForbidden is raised. And that's about it!","title":"API example"},{"location":"integrate/python/flask/#web-application-example","text":"This is for you if... Your Flask backend will render HTML pages. Your application is intended to be used in a browser. The examples we showed previously are working well in a pure REST API context: a frontend, like the interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application, where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py from datetime import datetime from fief_client import Fief from fief_client.integrations.flask import ( FiefAuth , FiefAuthForbidden , FiefAuthUnauthorized , get_cookie , ) from flask import Flask , g , redirect , request , url_for SESSION_COOKIE_NAME = \"user_session\" fief = Fief ( # (1)! \"https://example.fief.dev\" , \"DOIhj_72Ha9rYh9uDgndSu62EXJuFfQ5lkkx1-ksUIo\" , \"WwOOiLopc5m_d_sjKk563oZDnbJDCWjJVmxkX1LffaQ\" , ) auth = FiefAuth ( fief , get_cookie ( SESSION_COOKIE_NAME )) # (2)! app = Flask ( __name__ ) @app . errorhandler ( FiefAuthUnauthorized ) # (3)! def fief_unauthorized_error ( e ): redirect_uri = url_for ( \"auth_callback\" , _external = True ) # (4)! auth_url = fief . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (5)! return redirect ( auth_url ) # (6)! @app . errorhandler ( FiefAuthForbidden ) def fief_forbidden_error ( e ): return \"\" , 403 @app . get ( \"/auth-callback\" ) # (7)! def auth_callback (): redirect_uri = url_for ( \"auth_callback\" , _external = True ) code = request . args [ \"code\" ] tokens , _ = fief . auth_callback ( code , redirect_uri ) # (8)! response = redirect ( url_for ( \"protected\" )) # (9)! response . set_cookie ( # (10)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (11)! secure = False , # \u274c Set this to `True` in production (12)! ) return response @app . get ( \"/protected\" ) @auth . current_user () # (13)! def protected (): user = g . user return f \"<h1>You are authenticated. Your user ID is { user [ 'id' ] } </h1>\" This doesn't change from the previous example The Fief client is always at the heart of the integration \ud83d\ude09 We use a cookie getter Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use the get_cookie getter. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. We change the error handler for FiefAuthUnauthorized This time, we'll generate a redirect response so the user can login on Fief. We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server Thanks to the auth_url method on the Fief client, we can automatically generate the authorization URL on the Fief server. We build a redirect response We redirect the user to the Fief authorization URL. We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. Use the current_user decorator as usual This doesn't change from the previous example. The dependency will check if the cookie is available in the request and proceed if everything goes well. Otherwise, an FiefAuthUnauthorized error will be raised and the user will be redirected to the Fief login page. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.","title":"Web application example"},{"location":"miscellaneous/resources/","text":"Resources \u00b6 RFC7517 (JSON Web Key): https://datatracker.ietf.org/doc/html/rfc7517 RFC7636 (OAuth2 PKCE): https://datatracker.ietf.org/doc/html/rfc7636 RFC8414 (OAuth2 Metadata): https://datatracker.ietf.org/doc/html/rfc8414 OpenID Connect 1.0 specification: https://openid.net/specs/openid-connect-core-1_0.html JWCrypto's library documentation: https://jwcrypto.readthedocs.io/","title":"Resources"},{"location":"miscellaneous/resources/#resources","text":"RFC7517 (JSON Web Key): https://datatracker.ietf.org/doc/html/rfc7517 RFC7636 (OAuth2 PKCE): https://datatracker.ietf.org/doc/html/rfc7636 RFC8414 (OAuth2 Metadata): https://datatracker.ietf.org/doc/html/rfc8414 OpenID Connect 1.0 specification: https://openid.net/specs/openid-connect-core-1_0.html JWCrypto's library documentation: https://jwcrypto.readthedocs.io/","title":"Resources"},{"location":"self-hosting/environment-variables/","text":"Environment variables \u00b6 Fief server relies heavily on environment variables for configuration. You'll likely need to adjust those settings for your deployment. Set environment variables \u00b6 Using docker run \u00b6 When running Fief server with Docker, the most straightforward way is to use the -e option on the command line, as shown in the Quickstart section. docker run \\ --name fief-server \\ -p 8000 :80 -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest However, it may become hard to maintain when having lot of variables to set. An alternative way is to use a .env file. It's a simple file where each line consists of a key and a value separated by an equal sign: .env SECRET = XXX FIEF_CLIENT_ID = XXX FIEF_CLIENT_SECRET = XXX ENCRYPTION_KEY = XXX Then, you can reference this file in the Docker command: docker run \\ --name fief-server \\ -p 8000 :80 -d \\ --env-file .env \\ ghcr.io/fief-dev/fief:latest Using Docker Compose \u00b6 For more complex setups, you may need to configure a Docker Compose file to help you manage all your containers. You can directly define your environment variables in the Compose file. You'll find below an example of a Docker Compose file to run the Fief server. docker-compose.yml version : \"3.9\" services : fief : image : ghcr.io/fief-dev/fief:latest ports : - \"80:8000\" environment : - SECRET=XXX - FIEF_CLIENT_ID=XXX - FIEF_CLIENT_SECRET=XXX - ENCRYPTION_KEY=XXX Reference \u00b6 For each variable, we'll try to provide a sensible example value to help you configure it correctly. Throughout the examples, we'll assume that you host your Fief server on the sub-domain fief.bretagne.duchy . General \u00b6 Name Description Default Allowed values Example ENVIRONMENT Name of the deployment environment development development, staging, production production LOG_LEVEL Log verbosity DEBUG DEBUG, INFO, WARNING, ERROR INFO ROOT_DOMAIN Root domain where your server will be running. Mainly used for generating workspace subdomains. localhost bretagne.duchy ALLOW_ORIGIN_REGEX Regex used to control CORS access to your API http://.*localhost:[0-9]+ https://.*\\.bretagne.duchy Secrets \u00b6 Name Description Default Allowed values Example SECRET Secret value used to sign reset password tokens. Any sufficiently long string ENCRYPTION_KEY Key used to encrypt the external databases credentials inside the main database A valid Fernet key encoded in UTF-8 Database \u00b6 Name Description Default Allowed values Example DATABASE_TYPE Type of the main database SQLITE POSTGRESQL, MYSQL, SQLITE POSTGRESQL DATABASE_HOST Host of the main database localhost DATABASE_PORT Listening port of the main database 5432 DATABASE_USERNAME Main database user fief DATABASE_PASSWORD Main database user's password fiefpassword DATABASE_NAME Main database name fief.db fief DATABASE_LOCATION For SQLite databases, path where to store the database files Current working directory DATABASE_URL Full database connection string, useful for some cloud providers. It'll take precedence over the single parameters above. More details about how to setup a database in the dedicated section. Setup database Redis \u00b6 We use a Redis instance to manage background jobs (send emails, heavy computations...). A Redis instance is already up-and-running in the official Docker image, but you can provide your own one if needed. Name Description Default Allowed values Example REDIS_URL URL of a Redis server redis://localhost:6379 Email provider \u00b6 Name Description Default Allowed values Example EMAIL_PROVIDER Type of email provider NULL NULL, POSTMARK POSTMARK EMAIL_PROVIDER_PARAMS Configuration dictionary of the email provider {} {\"server_token\": \"XXX-XXX\"} More details about how to setup an email provider in the dedicated section. Setup email provider CSRF cookie \u00b6 To protect against Cross-Site-Request-Forgery attacks on authentication pages, we use the double-submit cookie pattern. Name Description Default Allowed values Example CSRF_COOKIE_NAME Name of the CSRF token cookie fief_csrftoken CSRF_COOKIE_SECURE Secure flag of the login session cookie True Login session \u00b6 A login session is a cookie used to maintain the state of the login flow of a user, from the login page until they're redirected to your application. Name Description Default Allowed values Example LOGIN_SESSION_COOKIE_NAME Name of the login session cookie fief_login_session LOGIN_SESSION_COOKIE_DOMAIN Domain of the login session cookie Empty string LOGIN_SESSION_COOKIE_SECURE Secure flag of the login session cookie True Session \u00b6 A session is a cookie used to maintain the session of a user on the Fief authentication pages . It's different from the session you'll maintain in your own application. Its purpose is to allow a user to re-authenticate quickly to your app without having them to input their credentials again. Name Description Default Allowed values Example SESSION_COOKIE_NAME Name of the session cookie fief_session SESSION_COOKIE_DOMAIN Domain of the session cookie Empty string SESSION_COOKIE_SECURE Secure flag of the session cookie True SESSION_LIFETIME_SECONDS Lifetime of the session cookie in seconds 86400 * 30 (30 days ) Authorization code \u00b6 Authorization codes are temporary codes generated during the OAuth2 authentication flow . Name Description Default Allowed values Example AUTHORIZATION_CODE_LIFETIME_SECONDS Lifetime of the authorization code in seconds. For security reasons, this value should remain low. OAuth2 specification recommends a value of 10 minutes . 600 (10 minutes) Fief-ception \u00b6 Fief-ception is a mind-fucking concept describing the fact that we actually use Fief to authenticate Fief users to the app \ud83e\udd2f That's why we necessarily need to create a first workspace and an admin user before being able to use Fief, as described in the Quickstart section. The variables below are here to configure the Fief server with a proper Fief client, as you would do in your own application! Name Description Default Allowed values Example FIEF_DOMAIN Domain of your main Fief workspace localhost fief.bretagne.duchy FIEF_BASE_URL URL of the main Fief workspace. It calls itself! http://localhost https://fief.bretagne.duchy FIEF_CLIENT_ID Client ID in your main Fief workspace FIEF_CLIENT_SECRET Client secret in your main Fief workspace FIEF_ENCRYPTION_KEY Optional RSA key used to encrypt the JWT tokens Admin session \u00b6 An admin session is a cookie used to maintain the session of a user on the Fief admin dashboard. Name Description Default Allowed values Example FIEF_ADMIN_SESSION_COOKIE_NAME Name of the admin session cookie fief_admin_session FIEF_ADMIN_SESSION_COOKIE_DOMAIN Domain of the admin session cookie Empty string FIEF_ADMIN_SESSION_COOKIE_SECURE Secure flag of the admin session cookie True","title":"Environment variables"},{"location":"self-hosting/environment-variables/#environment-variables","text":"Fief server relies heavily on environment variables for configuration. You'll likely need to adjust those settings for your deployment.","title":"Environment variables"},{"location":"self-hosting/environment-variables/#set-environment-variables","text":"","title":"Set environment variables"},{"location":"self-hosting/environment-variables/#using-docker-run","text":"When running Fief server with Docker, the most straightforward way is to use the -e option on the command line, as shown in the Quickstart section. docker run \\ --name fief-server \\ -p 8000 :80 -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest However, it may become hard to maintain when having lot of variables to set. An alternative way is to use a .env file. It's a simple file where each line consists of a key and a value separated by an equal sign: .env SECRET = XXX FIEF_CLIENT_ID = XXX FIEF_CLIENT_SECRET = XXX ENCRYPTION_KEY = XXX Then, you can reference this file in the Docker command: docker run \\ --name fief-server \\ -p 8000 :80 -d \\ --env-file .env \\ ghcr.io/fief-dev/fief:latest","title":"Using docker run"},{"location":"self-hosting/environment-variables/#using-docker-compose","text":"For more complex setups, you may need to configure a Docker Compose file to help you manage all your containers. You can directly define your environment variables in the Compose file. You'll find below an example of a Docker Compose file to run the Fief server. docker-compose.yml version : \"3.9\" services : fief : image : ghcr.io/fief-dev/fief:latest ports : - \"80:8000\" environment : - SECRET=XXX - FIEF_CLIENT_ID=XXX - FIEF_CLIENT_SECRET=XXX - ENCRYPTION_KEY=XXX","title":"Using Docker Compose"},{"location":"self-hosting/environment-variables/#reference","text":"For each variable, we'll try to provide a sensible example value to help you configure it correctly. Throughout the examples, we'll assume that you host your Fief server on the sub-domain fief.bretagne.duchy .","title":"Reference"},{"location":"self-hosting/environment-variables/#general","text":"Name Description Default Allowed values Example ENVIRONMENT Name of the deployment environment development development, staging, production production LOG_LEVEL Log verbosity DEBUG DEBUG, INFO, WARNING, ERROR INFO ROOT_DOMAIN Root domain where your server will be running. Mainly used for generating workspace subdomains. localhost bretagne.duchy ALLOW_ORIGIN_REGEX Regex used to control CORS access to your API http://.*localhost:[0-9]+ https://.*\\.bretagne.duchy","title":"General"},{"location":"self-hosting/environment-variables/#secrets","text":"Name Description Default Allowed values Example SECRET Secret value used to sign reset password tokens. Any sufficiently long string ENCRYPTION_KEY Key used to encrypt the external databases credentials inside the main database A valid Fernet key encoded in UTF-8","title":"Secrets"},{"location":"self-hosting/environment-variables/#database","text":"Name Description Default Allowed values Example DATABASE_TYPE Type of the main database SQLITE POSTGRESQL, MYSQL, SQLITE POSTGRESQL DATABASE_HOST Host of the main database localhost DATABASE_PORT Listening port of the main database 5432 DATABASE_USERNAME Main database user fief DATABASE_PASSWORD Main database user's password fiefpassword DATABASE_NAME Main database name fief.db fief DATABASE_LOCATION For SQLite databases, path where to store the database files Current working directory DATABASE_URL Full database connection string, useful for some cloud providers. It'll take precedence over the single parameters above. More details about how to setup a database in the dedicated section. Setup database","title":"Database"},{"location":"self-hosting/environment-variables/#redis","text":"We use a Redis instance to manage background jobs (send emails, heavy computations...). A Redis instance is already up-and-running in the official Docker image, but you can provide your own one if needed. Name Description Default Allowed values Example REDIS_URL URL of a Redis server redis://localhost:6379","title":"Redis"},{"location":"self-hosting/environment-variables/#email-provider","text":"Name Description Default Allowed values Example EMAIL_PROVIDER Type of email provider NULL NULL, POSTMARK POSTMARK EMAIL_PROVIDER_PARAMS Configuration dictionary of the email provider {} {\"server_token\": \"XXX-XXX\"} More details about how to setup an email provider in the dedicated section. Setup email provider","title":"Email provider"},{"location":"self-hosting/environment-variables/#csrf-cookie","text":"To protect against Cross-Site-Request-Forgery attacks on authentication pages, we use the double-submit cookie pattern. Name Description Default Allowed values Example CSRF_COOKIE_NAME Name of the CSRF token cookie fief_csrftoken CSRF_COOKIE_SECURE Secure flag of the login session cookie True","title":"CSRF cookie"},{"location":"self-hosting/environment-variables/#login-session","text":"A login session is a cookie used to maintain the state of the login flow of a user, from the login page until they're redirected to your application. Name Description Default Allowed values Example LOGIN_SESSION_COOKIE_NAME Name of the login session cookie fief_login_session LOGIN_SESSION_COOKIE_DOMAIN Domain of the login session cookie Empty string LOGIN_SESSION_COOKIE_SECURE Secure flag of the login session cookie True","title":"Login session"},{"location":"self-hosting/environment-variables/#session","text":"A session is a cookie used to maintain the session of a user on the Fief authentication pages . It's different from the session you'll maintain in your own application. Its purpose is to allow a user to re-authenticate quickly to your app without having them to input their credentials again. Name Description Default Allowed values Example SESSION_COOKIE_NAME Name of the session cookie fief_session SESSION_COOKIE_DOMAIN Domain of the session cookie Empty string SESSION_COOKIE_SECURE Secure flag of the session cookie True SESSION_LIFETIME_SECONDS Lifetime of the session cookie in seconds 86400 * 30 (30 days )","title":"Session"},{"location":"self-hosting/environment-variables/#authorization-code","text":"Authorization codes are temporary codes generated during the OAuth2 authentication flow . Name Description Default Allowed values Example AUTHORIZATION_CODE_LIFETIME_SECONDS Lifetime of the authorization code in seconds. For security reasons, this value should remain low. OAuth2 specification recommends a value of 10 minutes . 600 (10 minutes)","title":"Authorization code"},{"location":"self-hosting/environment-variables/#fief-ception","text":"Fief-ception is a mind-fucking concept describing the fact that we actually use Fief to authenticate Fief users to the app \ud83e\udd2f That's why we necessarily need to create a first workspace and an admin user before being able to use Fief, as described in the Quickstart section. The variables below are here to configure the Fief server with a proper Fief client, as you would do in your own application! Name Description Default Allowed values Example FIEF_DOMAIN Domain of your main Fief workspace localhost fief.bretagne.duchy FIEF_BASE_URL URL of the main Fief workspace. It calls itself! http://localhost https://fief.bretagne.duchy FIEF_CLIENT_ID Client ID in your main Fief workspace FIEF_CLIENT_SECRET Client secret in your main Fief workspace FIEF_ENCRYPTION_KEY Optional RSA key used to encrypt the JWT tokens","title":"Fief-ception"},{"location":"self-hosting/environment-variables/#admin-session","text":"An admin session is a cookie used to maintain the session of a user on the Fief admin dashboard. Name Description Default Allowed values Example FIEF_ADMIN_SESSION_COOKIE_NAME Name of the admin session cookie fief_admin_session FIEF_ADMIN_SESSION_COOKIE_DOMAIN Domain of the admin session cookie Empty string FIEF_ADMIN_SESSION_COOKIE_SECURE Secure flag of the admin session cookie True","title":"Admin session"},{"location":"self-hosting/quickstart/","text":"Quickstart \u00b6 We provide a Docker image to help you start the Fief server locally in no time! Run the following command: docker run --rm ghcr.io/fief-dev/fief:latest fief quickstart --docker The result of this command is a complete docker run command with the required secrets generated to help you get started. It'll look like the following: docker run \\ --name fief-server \\ -p 8000 :80 -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest Save those secrets somewhere safe! If you need restart or recreate your container, you'll probably need to set the same secrets again. If you lose them, you'll likely lose access to data or have a bad configuration. Read more about secrets and environment variables. Info The container is exposed on the port 8000 of your local machine by default, but you can set any port you want. Create main workspace \u00b6 Next, you'll need to create the main workspace . Simply run the following command: docker exec fief-server fief create-main-workspace You should see the following output: Main Fief workspace created Create admin user \u00b6 Finally, you need to create an admin user for this main workspace that'll have access to the admin dashboard. Run the following command: docker exec -it fief-server fief create-main-user --user-email anne@bretagne.duchy Tip Of course, make sure to replace --user-email value with your own email address! You'll then be prompted for a password. If everything goes well, you should see the following output: Main Fief user created Good to go! \u00b6 At this point, your Fief server should be up-and-running! Open http://localhost:8000/admin/ to access the admin dashboard. You'll be redirected to a login page. Authenticate with the user credentials you created in the previous section. You'll then be redirected to the admin dashboard. Congratulations! Your Fief server instance is up-and-running \ud83c\udf89 You can now try Fief features and start to integrate authentication in your app. Tip For production deployment, we strongly recommend you to read the next sections. Limitations \u00b6 While quick and convenient, this way of running Fief is not suitable for production environments . Under the hood, it stores the data in the form of SQLite databases . If you ever happen to destroy your container, you'll lose all your data. The best way is of course to configure a proper PostgreSQL or MySQL database for your Fief server, as described in the dedicated section. Setup database Use a Docker volume to persist SQLite data \u00b6 If you really want to use SQLite, or mitigate the risk of losing data in your local environment, you can attach your container to a Docker volume . This way, even if the container is destroyed, you can create a new one and attach again the data. The first thing to do is to create a Docker volume: docker volume create fief-server-data Then, create your Fief server container and attach this volume to the /data folder on the container: docker run \\ --name fief-server \\ -p 8000 :80 -d \\ -v fief-server-volume:/data \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest Warning If you created your container with the instructions in the previous section, you'll need to recreate one from scratch to bind the volume.","title":"Quickstart"},{"location":"self-hosting/quickstart/#quickstart","text":"We provide a Docker image to help you start the Fief server locally in no time! Run the following command: docker run --rm ghcr.io/fief-dev/fief:latest fief quickstart --docker The result of this command is a complete docker run command with the required secrets generated to help you get started. It'll look like the following: docker run \\ --name fief-server \\ -p 8000 :80 -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest Save those secrets somewhere safe! If you need restart or recreate your container, you'll probably need to set the same secrets again. If you lose them, you'll likely lose access to data or have a bad configuration. Read more about secrets and environment variables. Info The container is exposed on the port 8000 of your local machine by default, but you can set any port you want.","title":"Quickstart"},{"location":"self-hosting/quickstart/#create-main-workspace","text":"Next, you'll need to create the main workspace . Simply run the following command: docker exec fief-server fief create-main-workspace You should see the following output: Main Fief workspace created","title":"Create main workspace"},{"location":"self-hosting/quickstart/#create-admin-user","text":"Finally, you need to create an admin user for this main workspace that'll have access to the admin dashboard. Run the following command: docker exec -it fief-server fief create-main-user --user-email anne@bretagne.duchy Tip Of course, make sure to replace --user-email value with your own email address! You'll then be prompted for a password. If everything goes well, you should see the following output: Main Fief user created","title":"Create admin user"},{"location":"self-hosting/quickstart/#good-to-go","text":"At this point, your Fief server should be up-and-running! Open http://localhost:8000/admin/ to access the admin dashboard. You'll be redirected to a login page. Authenticate with the user credentials you created in the previous section. You'll then be redirected to the admin dashboard. Congratulations! Your Fief server instance is up-and-running \ud83c\udf89 You can now try Fief features and start to integrate authentication in your app. Tip For production deployment, we strongly recommend you to read the next sections.","title":"Good to go!"},{"location":"self-hosting/quickstart/#limitations","text":"While quick and convenient, this way of running Fief is not suitable for production environments . Under the hood, it stores the data in the form of SQLite databases . If you ever happen to destroy your container, you'll lose all your data. The best way is of course to configure a proper PostgreSQL or MySQL database for your Fief server, as described in the dedicated section. Setup database","title":"Limitations"},{"location":"self-hosting/quickstart/#use-a-docker-volume-to-persist-sqlite-data","text":"If you really want to use SQLite, or mitigate the risk of losing data in your local environment, you can attach your container to a Docker volume . This way, even if the container is destroyed, you can create a new one and attach again the data. The first thing to do is to create a Docker volume: docker volume create fief-server-data Then, create your Fief server container and attach this volume to the /data folder on the container: docker run \\ --name fief-server \\ -p 8000 :80 -d \\ -v fief-server-volume:/data \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest Warning If you created your container with the instructions in the previous section, you'll need to recreate one from scratch to bind the volume.","title":"Use a Docker volume to persist SQLite data"},{"location":"self-hosting/setup-database/","text":"Setup database \u00b6 For production environments, your Fief server should store its data in a proper database server for better performance and reliability. Fief is compatible with PostgreSQL and MySQL databases. Setup PostgreSQL \u00b6 We'll assume that you have a working PostgreSQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = POSTGRESQL DATABASE_HOST = localhost DATABASE_PORT = 5432 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section . Setup MySQL \u00b6 We'll assume that you have a working MySQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = MYSQL DATABASE_HOST = localhost DATABASE_PORT = 3306 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section . Use a connection string \u00b6 Some cloud providers like Heroku will provide you a full database connection string like the one below instead of each parts separately: postgresql://fief:fiefpassword@localhost:5432/fief Fief supports this kind of configuration with the DATABASE_URL environment variable. DATABASE_TYPE = POSTGRESQL DATABASE_URL = postgresql://fief:fiefpassword@localhost:5432/fief Warning This variable will always take precedence over the single parameters: if you define DATABASE_URL , it'll use this variable to connect to your database, even if other parameters are defined. Create main workspace and admin user \u00b6 Once your database is configured, don't forget to create the main workspace and admin user, as described in the Quickstart section.","title":"Setup database"},{"location":"self-hosting/setup-database/#setup-database","text":"For production environments, your Fief server should store its data in a proper database server for better performance and reliability. Fief is compatible with PostgreSQL and MySQL databases.","title":"Setup database"},{"location":"self-hosting/setup-database/#setup-postgresql","text":"We'll assume that you have a working PostgreSQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = POSTGRESQL DATABASE_HOST = localhost DATABASE_PORT = 5432 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Setup PostgreSQL"},{"location":"self-hosting/setup-database/#setup-mysql","text":"We'll assume that you have a working MySQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = MYSQL DATABASE_HOST = localhost DATABASE_PORT = 3306 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Setup MySQL"},{"location":"self-hosting/setup-database/#use-a-connection-string","text":"Some cloud providers like Heroku will provide you a full database connection string like the one below instead of each parts separately: postgresql://fief:fiefpassword@localhost:5432/fief Fief supports this kind of configuration with the DATABASE_URL environment variable. DATABASE_TYPE = POSTGRESQL DATABASE_URL = postgresql://fief:fiefpassword@localhost:5432/fief Warning This variable will always take precedence over the single parameters: if you define DATABASE_URL , it'll use this variable to connect to your database, even if other parameters are defined.","title":"Use a connection string"},{"location":"self-hosting/setup-database/#create-main-workspace-and-admin-user","text":"Once your database is configured, don't forget to create the main workspace and admin user, as described in the Quickstart section.","title":"Create main workspace and admin user"},{"location":"self-hosting/setup-email-provider/","text":"Setup email provider \u00b6 As you surely now, users management imply a lot of transactional emails, like welcome emails or reset password emails. To be able to send them, Fief needs an email provider. Currently, Fief only supports Postmark , one of the leading email delivery service on the market, but we may support more in the future. There are two environment variables to configure the email provider: EMAIL_PROVIDER , to set the type of provider and EMAIL_PROVIDER_PARAMS , a configuration dictionary containing required configuration keys. NULL provider \u00b6 The NULL provider is the default one if you don't set any. It means that no transactional email will be sent . EMAIL_PROVIDER = NULL Postmark provider \u00b6 Postmark provider will send transactional emails using Postmark . Parameter Description server_token Your Postmark Server API token EMAIL_PROVIDER = POSTMARK EMAIL_PROVIDER_PARAMS = {\"server_token\": \"XXX-XXX\"} Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Setup email provider"},{"location":"self-hosting/setup-email-provider/#setup-email-provider","text":"As you surely now, users management imply a lot of transactional emails, like welcome emails or reset password emails. To be able to send them, Fief needs an email provider. Currently, Fief only supports Postmark , one of the leading email delivery service on the market, but we may support more in the future. There are two environment variables to configure the email provider: EMAIL_PROVIDER , to set the type of provider and EMAIL_PROVIDER_PARAMS , a configuration dictionary containing required configuration keys.","title":"Setup email provider"},{"location":"self-hosting/setup-email-provider/#null-provider","text":"The NULL provider is the default one if you don't set any. It means that no transactional email will be sent . EMAIL_PROVIDER = NULL","title":"NULL provider"},{"location":"self-hosting/setup-email-provider/#postmark-provider","text":"Postmark provider will send transactional emails using Postmark . Parameter Description server_token Your Postmark Server API token EMAIL_PROVIDER = POSTMARK EMAIL_PROVIDER_PARAMS = {\"server_token\": \"XXX-XXX\"} Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Postmark provider"}]}