{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Fief? Fief is an open-source platform to manage users and authentication in your applications. Our goal is to help you manage users and security in a matter of minutes, not days. Key features: Pre-built login and registration pages Users management dashboard SDK for the most popular languages and frameworks Integrations for the most popular no-code tools Bring Your Own Database : you can connect to any SQL database so you keep entire control of your data Cloud vs Self-hosted We are offering two ways of using Fief: Cloud : fair-priced hosted instance, maintained by the Fief's team; Self-hosted : you host the service yourself on your own infrastructure, for free.","title":"What is Fief?"},{"location":"#what-is-fief","text":"Fief is an open-source platform to manage users and authentication in your applications. Our goal is to help you manage users and security in a matter of minutes, not days. Key features: Pre-built login and registration pages Users management dashboard SDK for the most popular languages and frameworks Integrations for the most popular no-code tools Bring Your Own Database : you can connect to any SQL database so you keep entire control of your data","title":"What is Fief?"},{"location":"#cloud-vs-self-hosted","text":"We are offering two ways of using Fief: Cloud : fair-priced hosted instance, maintained by the Fief's team; Self-hosted : you host the service yourself on your own infrastructure, for free.","title":"Cloud vs Self-hosted"},{"location":"getting-started/admin-dashboard/","text":"Admin dashboard The admin dashboard is the interface where you'll be able to manage your Fief workspace and configuration. The left menu lets you access to the most important aspects of Fief: Tenants Clients Users API Keys Switch workspace If your account is linked to several workspaces, you can switch to another workspace using the menu on the top-right.","title":"Admin dashboard"},{"location":"getting-started/admin-dashboard/#admin-dashboard","text":"The admin dashboard is the interface where you'll be able to manage your Fief workspace and configuration. The left menu lets you access to the most important aspects of Fief: Tenants Clients Users API Keys","title":"Admin dashboard"},{"location":"getting-started/admin-dashboard/#switch-workspace","text":"If your account is linked to several workspaces, you can switch to another workspace using the menu on the top-right.","title":"Switch workspace"},{"location":"getting-started/clients/","text":"Clients This is where you'll see and manage the clients of your workspace. What is a client? A client is a central part of the OAuth2 protocol. It's the definition of an application authorized to request for access tokens and user information on Fief. In other words, your application will need one of those client to be able to authenticate users from your Fief workspace. Each client has a Client ID and a Client Secret. Those values are used during OAuth2 authentification to recognize the client. Each workspace comes with one client, tied to the default tenant . First-party clients You probably noticed that your first client has a first-party badge. It means that this client is intended to be used by your own, official application. In this context, when users log in to your application, the traditional OAuth2 consent screen is bypassed . Since you are the developer of the application, it makes sense to not ask the user for their consent to use their data on the same application! For third-party applications, like developers from another company who want to integrate your API in their product, you'll provide them a client without this first-party flag. In this context, we want the user consent to be explicit. View client details If you click on one of the client in the list, you'll see its details on the right. Especially, you'll be able to copy its ID and Secret by using the clipboard buttons. Create a new client You can create a new client by clicking the Create Client button. A modal will open where you'll be able to input its name, if it's a first-party and its associated tenant. When should I create a new client? If you have several applications authenticating to your Fief workspace, you should consider creating new clients. Typically, if you have both a web applicationd and a mobile application, it's usually a good idea to have a client for each one. This way, it's easier to track down where the tokens come from and mitigate the risk of compromising data if one of the application has a security breach.","title":"Clients"},{"location":"getting-started/clients/#clients","text":"This is where you'll see and manage the clients of your workspace. What is a client? A client is a central part of the OAuth2 protocol. It's the definition of an application authorized to request for access tokens and user information on Fief. In other words, your application will need one of those client to be able to authenticate users from your Fief workspace. Each client has a Client ID and a Client Secret. Those values are used during OAuth2 authentification to recognize the client. Each workspace comes with one client, tied to the default tenant .","title":"Clients"},{"location":"getting-started/clients/#first-party-clients","text":"You probably noticed that your first client has a first-party badge. It means that this client is intended to be used by your own, official application. In this context, when users log in to your application, the traditional OAuth2 consent screen is bypassed . Since you are the developer of the application, it makes sense to not ask the user for their consent to use their data on the same application! For third-party applications, like developers from another company who want to integrate your API in their product, you'll provide them a client without this first-party flag. In this context, we want the user consent to be explicit.","title":"First-party clients"},{"location":"getting-started/clients/#view-client-details","text":"If you click on one of the client in the list, you'll see its details on the right. Especially, you'll be able to copy its ID and Secret by using the clipboard buttons.","title":"View client details"},{"location":"getting-started/clients/#create-a-new-client","text":"You can create a new client by clicking the Create Client button. A modal will open where you'll be able to input its name, if it's a first-party and its associated tenant. When should I create a new client? If you have several applications authenticating to your Fief workspace, you should consider creating new clients. Typically, if you have both a web applicationd and a mobile application, it's usually a good idea to have a client for each one. This way, it's easier to track down where the tokens come from and mitigate the risk of compromising data if one of the application has a security breach.","title":"Create a new client"},{"location":"getting-started/introduction/","text":"Introduction Fief is what is usually called an identity provider : it provides and secures user identities to external apps. To allow this, Fief implements the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol . Basically, it describes a secure way for a user to give access to its data to an external app. So, how does everything will fit together? In a nutshell, Fief will store everything about your users data (email address, hashed passwords...) and give you a simple way to authenticate them in your application. graph TD U((User)) A{Your application} subgraph FIEF [Fief] F[Fief API] FL[Login page] FD[(Fief database)] end U -- is not authenticated ----> FL U -- is authenticated ----> A A -- checks user identity on --> F FL -. redirects to .-> A F -- stores users on --> FD Let's get started! The first thing to do is to create your workspace!","title":"Introduction"},{"location":"getting-started/introduction/#introduction","text":"Fief is what is usually called an identity provider : it provides and secures user identities to external apps. To allow this, Fief implements the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol . Basically, it describes a secure way for a user to give access to its data to an external app. So, how does everything will fit together? In a nutshell, Fief will store everything about your users data (email address, hashed passwords...) and give you a simple way to authenticate them in your application. graph TD U((User)) A{Your application} subgraph FIEF [Fief] F[Fief API] FL[Login page] FD[(Fief database)] end U -- is not authenticated ----> FL U -- is authenticated ----> A A -- checks user identity on --> F FL -. redirects to .-> A F -- stores users on --> FD","title":"Introduction"},{"location":"getting-started/introduction/#lets-get-started","text":"The first thing to do is to create your workspace!","title":"Let's get started!"},{"location":"getting-started/tenants/","text":"Tenants This is where you'll see and manage the tenants of your workspace. What is a tenant? A tenant is a sub-division of your workspace. Each client and user is tied to a specific tenant. This is mostly useful if you want to create a product sold in white-label where each of your client has its own space. It allows for example for a user to have several accounts with the same email address inside one workspace, but actually tied to different tenants. From a user point-of-view, this is a different application on which they login with different credentials. If you don't plan to do this, that's okay: you'll always use a single tenant in your workspace. Each workspace has at least one default tenant. Base URL Each tenant is tied to a base URL : each routes, like login or registration, will be derived from this base. When you integrate Fief in your application, you'll need this base URL. Each workspace has one default tenant with a base URL pointing to your root subdomain, like https://example.fief.dev . Other tenants gets a path prefix, like https://example.fief.dev/other-tenant . Tip You can copy the base URL directly using the clipboard button in the list. Limitation At the moment, new tenants can't be created from the admin dashboard.","title":"Tenants"},{"location":"getting-started/tenants/#tenants","text":"This is where you'll see and manage the tenants of your workspace. What is a tenant? A tenant is a sub-division of your workspace. Each client and user is tied to a specific tenant. This is mostly useful if you want to create a product sold in white-label where each of your client has its own space. It allows for example for a user to have several accounts with the same email address inside one workspace, but actually tied to different tenants. From a user point-of-view, this is a different application on which they login with different credentials. If you don't plan to do this, that's okay: you'll always use a single tenant in your workspace. Each workspace has at least one default tenant.","title":"Tenants"},{"location":"getting-started/tenants/#base-url","text":"Each tenant is tied to a base URL : each routes, like login or registration, will be derived from this base. When you integrate Fief in your application, you'll need this base URL. Each workspace has one default tenant with a base URL pointing to your root subdomain, like https://example.fief.dev . Other tenants gets a path prefix, like https://example.fief.dev/other-tenant . Tip You can copy the base URL directly using the clipboard button in the list. Limitation At the moment, new tenants can't be created from the admin dashboard.","title":"Base URL"},{"location":"getting-started/workspace/","text":"Create your workspace The easiest way to get started is to create your workspace on our official Fief instance . After having created your user account, you'll be guided through the creation of your workspace . What is a workspace? A workspace is a place where all your Fief data lives: configuration, users data, etc. Each workspace has its own subdomain reserved for you, like https://example.fief.dev . If you are working on several projects or companies, we recommend to create several workspaces to keep things organized. Step 1: name your workspace The first step is to name your workspace. Use a name describing your application or company: it'll be used to generate your workspace subdomain. For example, a workspace named Bretagne Duchy will be assigned to the subdomain https://bretagne-duchy.fief.dev . Step 2: select your type of database One of the great strength of Fief is that you can bring your own database to store your workspace data. This way, you keep in total control of your data. Of course, we also propose you to store your data on our performand and secure cloud database. Your choice! At this step, you can make the choice between the Fief cloud database or configure your own. For the sake of simplicity, we'll choose here the cloud database . If you want to bring your own database, we recommend you to read the dedicated section . Ready to go! That's it! At this point, everything is ready to create your workspace! After that, you'll be redirected to your admin dashboard, where you'll be able to manage your workspace.","title":"Create your workspace"},{"location":"getting-started/workspace/#create-your-workspace","text":"The easiest way to get started is to create your workspace on our official Fief instance . After having created your user account, you'll be guided through the creation of your workspace . What is a workspace? A workspace is a place where all your Fief data lives: configuration, users data, etc. Each workspace has its own subdomain reserved for you, like https://example.fief.dev . If you are working on several projects or companies, we recommend to create several workspaces to keep things organized.","title":"Create your workspace"},{"location":"getting-started/workspace/#step-1-name-your-workspace","text":"The first step is to name your workspace. Use a name describing your application or company: it'll be used to generate your workspace subdomain. For example, a workspace named Bretagne Duchy will be assigned to the subdomain https://bretagne-duchy.fief.dev .","title":"Step 1: name your workspace"},{"location":"getting-started/workspace/#step-2-select-your-type-of-database","text":"One of the great strength of Fief is that you can bring your own database to store your workspace data. This way, you keep in total control of your data. Of course, we also propose you to store your data on our performand and secure cloud database. Your choice! At this step, you can make the choice between the Fief cloud database or configure your own. For the sake of simplicity, we'll choose here the cloud database . If you want to bring your own database, we recommend you to read the dedicated section .","title":"Step 2: select your type of database"},{"location":"getting-started/workspace/#ready-to-go","text":"That's it! At this point, everything is ready to create your workspace! After that, you'll be redirected to your admin dashboard, where you'll be able to manage your workspace.","title":"Ready to go!"},{"location":"going-further/byod/","text":"Bring your own database","title":"Bring your own database"},{"location":"going-further/byod/#bring-your-own-database","text":"","title":"Bring your own database"},{"location":"going-further/id-token-encryption/","text":"ID Token encryption","title":"ID Token encryption"},{"location":"going-further/id-token-encryption/#id-token-encryption","text":"","title":"ID Token encryption"},{"location":"integrate/javascript/","text":"\ud83d\udfe8 JavaScript","title":"\ud83d\udfe8 JavaScript"},{"location":"integrate/javascript/#javascript","text":"","title":"\ud83d\udfe8 JavaScript"},{"location":"integrate/nodejs/","text":"\ud83d\udfe2 NodeJS","title":"\ud83d\udfe2 NodeJS"},{"location":"integrate/nodejs/#nodejs","text":"","title":"\ud83d\udfe2 NodeJS"},{"location":"integrate/python/","text":"Python We provide an official client for Python. You can install it with pip : pip install fief-client Create a Fief client The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Base URL of your Fief tenant You can find it in the admin dashboard, in the Tenants list. More info ID of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Secret of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Async support For asyncio enthusiasts, we also provide a FiefAsync class with the same methods. Perform an OAuth2 flow manually The simple script below shows you how to authenticate with OAuth2 \"manually\". The goal is to show you how to use the client. You'll then be able to integrate it in your own project with your framework and stack. The first step is to generate an authorization URL , which is an URL on the Fief server that'll ask you for your email address and password. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Then, we make the script prompt for the authorization code . client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) This temporary code is generated by Fief upon successful login and can be used to obtain valid tokens. Fief returns both an access token and an ID token , which contains information about the user. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Test it You can run this script from a command line: python client.py You'll get the following output: Open this URL in your browser: https://example.fief.dev/authorize?response_type=code&client_id=YOUR_CLIENT_ID&redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fcallback&scope=openid Paste the callback code: You can copy and paste this URL manually in your browser . You'll be redirected to a Fief login page. Upon successful login, Fief will redirect to the redirect URL you defined above, including a query parameter named code . It'll look like this: http://localhost:8000/redirect?code=wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Your browser will probably show an error at this point In this simple implementation, we don't have a web server running on our local machine, so the browser won't be able to open the redirect URL. It's not a problem: what we care about is retrieving the authorization code by hand. Copy the code value, get back to the command line where the script is running and paste it. You'll get the following output: Paste the callback code: wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Tokens: {'access_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInNjb3BlIjoib3BlbmlkIiwic3ViIjoiYTM4NDZjYzEtN2MwOC00Mzg5LThjOGUtYzBlNzlmNzA3NWZlIn0.R5JnZW9Vq6lWai-FZcqsihYxmtFRbIjZ7D0Ck9XAG0d2YnQQ7ms3bUwtXEAnLhos4C3paGDa0PzQRtXSAx4IH85ZdeVJoBk9GrOj1ZV7E6dtZZSZlvtY2msMeXFC9gNg-A86R9ZU_T0PoROof0u1eJHYVlmo_dv2fodyNqkDB8V6HK3vqf7jaqNQtk8Fg6eHKhwb-3bAtjb5cpWAAWhMSrHZzTWIYUvYsvwAas5ihgenv3UOkpcl_p7b7G9SDhGE5abPQQ7lvyfhYZE7CV1DzVRU6UL4N0D2l4uI3RJNOQoECvltfo2etYzp5viwAwvg9LUS3466Ra1i8beBKXsPFQ', 'id_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZW1haWwiOiJmcmFuY29pcyt0ZXN0QGZpZWYuZGV2IiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInN1YiI6ImEzODQ2Y2MxLTdjMDgtNDM4OS04YzhlLWMwZTc5ZjcwNzVmZSIsInRlbmFudF9pZCI6IjcwNDEzNWI2LTRiZmQtNGM1NS04MDkwLWM2MzhhNmJhNTNhMiJ9.ULQy7TlgF5_oQwwgA6ydTahTYE31obr4F3olJy-mgyPw67XstoJLM1VwUNawzyz2Iu2QDmgcBrH3OMVfgCkBAFk2sp-QQIDr9arIF1QXNKG65El3zgPQ5-niTTsIuAkemyjNGcpdrcN2b9FaeodzauO5eOjno60h5dTBbcLnqv00V-Jv6sq8lB8_o5JXHKWUoZZA2VFEDox9MXfhDqrvyHcitsIRWIy7XhILKcZ-JG_AMcXnuDcyMnsoy91-gJznvMk7_ty9eNWs8Cm0ZhK3nMqEKML4tXIREmIN-vYUGDtbDWX3O45N98ovu9gJi9S3aVOh-gZQsnwauJmlW82ZQQ', 'token_type': 'bearer', 'expires_in': 3600} Userinfo: {'aud': ['YOUR_CLIENT_ID'], 'azp': 'YOUR_CLIENT_ID', 'email': 'anne@bretagne.duchy', 'exp': 1648050423, 'iat': 1648046823, 'iss': 'https://example.fief.dev', 'sub': 'a3846cc1-7c08-4389-8c8e-c0e79f7075fe', 'tenant_id': '704135b6-4bfd-4c55-8090-c638a6ba53a2'} As you can see, we obtained a first dictionary tokens containing an access token, an ID token and other standard OAuth2 information. The second variable, userinfo , is a dictionary with the user data. It's actually the information contained in the ID token that the client decoded for you. What's next? You have the fundamental basics for performing an OAuth2 authentication with the Fief Python client. To help you further, we provide you helpers and examples for popular Python frameworks like Flask or FastAPI. Integrate with FastAPI Integrate with Flask Reference auth_url Returns an authorization URL. Parameters redirect_uri: str : Your callback URI where the user will be redirected after the service prompt. state: str = None : Optional string that will be returned back in the callback parameters to allow you to retrieve state information. scope: Optional[List[str]] = None : Optional list of scopes to ask for. extras_params: Optional[Dict[str, Any]] = None : Optional dictionary containing specific parameters. Example auth_url = fief . auth_url ( \"http://localhost:8000/callback\" , scope = [ \"openid\" ]) auth_callback Returns valid tokens and user info in exchange of an authorization code. Parameters code: str : The authorization code. redirect_uri: str : The exact same redirect_uri you passed to the authorization URL. Example tokens , userinfo = fief . auth_callback ( \"CODE\" , \"http://localhost:8000/callback\" ) auth_refresh_token Returns fresh tokens and user info in exchange of a refresh token. Parameters refresh_token: str : A valid refresh token. scope: Optional[List[str]] = None : Optional list of scopes to ask for. If not provided, the access token will share the same list of scopes as requested the first time. Otherwise, it should be a subset of the original list of scopes. Example tokens , userinfo = fief . auth_refresh_token ( \"REFRESH_TOKEN\" ) validate_access_token Checks if an access token is valid and optionally that it has a required list of scopes. Parameters access_token: str : The access token to validate. required_scope: Optional[List[str]] = None : Optional list of scopes to check for. Example from fief_client import FiefAccessTokenInvalid , FiefAccessTokenExpired , FiefAccessTokenMissingScope try : access_token_info = fief . validate_access_token ( \"ACCESS_TOKEN\" , required_scope = [ \"required_scope\" ]) except FiefAccessTokenInvalid : print ( \"Invalid access token\" ) except FiefAccessTokenExpired : print ( \"Expired access token\" ) except FiefAccessTokenMissingScope : print ( \"Missing required scope\" ) print ( access_token_info ) # {\"id\": \"USER_ID\", \"scope\": [\"openid\", \"required_scope\"], \"access_token\": \"ACCESS_TOKEN\"} userinfo Returns fresh user information from the Fief API using a valid access token. Parameters access_token: str : A valid access token Example userinfo = fief . userinfo ( \"ACCESS_TOKEN\" )","title":"Python"},{"location":"integrate/python/#python","text":"We provide an official client for Python. You can install it with pip : pip install fief-client","title":"Python"},{"location":"integrate/python/#create-a-fief-client","text":"The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Base URL of your Fief tenant You can find it in the admin dashboard, in the Tenants list. More info ID of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Secret of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Async support For asyncio enthusiasts, we also provide a FiefAsync class with the same methods.","title":"Create a Fief client"},{"location":"integrate/python/#perform-an-oauth2-flow-manually","text":"The simple script below shows you how to authenticate with OAuth2 \"manually\". The goal is to show you how to use the client. You'll then be able to integrate it in your own project with your framework and stack. The first step is to generate an authorization URL , which is an URL on the Fief server that'll ask you for your email address and password. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Then, we make the script prompt for the authorization code . client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) This temporary code is generated by Fief upon successful login and can be used to obtain valid tokens. Fief returns both an access token and an ID token , which contains information about the user. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" )","title":"Perform an OAuth2 flow manually"},{"location":"integrate/python/#test-it","text":"You can run this script from a command line: python client.py You'll get the following output: Open this URL in your browser: https://example.fief.dev/authorize?response_type=code&client_id=YOUR_CLIENT_ID&redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fcallback&scope=openid Paste the callback code: You can copy and paste this URL manually in your browser . You'll be redirected to a Fief login page. Upon successful login, Fief will redirect to the redirect URL you defined above, including a query parameter named code . It'll look like this: http://localhost:8000/redirect?code=wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Your browser will probably show an error at this point In this simple implementation, we don't have a web server running on our local machine, so the browser won't be able to open the redirect URL. It's not a problem: what we care about is retrieving the authorization code by hand. Copy the code value, get back to the command line where the script is running and paste it. You'll get the following output: Paste the callback code: wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Tokens: {'access_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInNjb3BlIjoib3BlbmlkIiwic3ViIjoiYTM4NDZjYzEtN2MwOC00Mzg5LThjOGUtYzBlNzlmNzA3NWZlIn0.R5JnZW9Vq6lWai-FZcqsihYxmtFRbIjZ7D0Ck9XAG0d2YnQQ7ms3bUwtXEAnLhos4C3paGDa0PzQRtXSAx4IH85ZdeVJoBk9GrOj1ZV7E6dtZZSZlvtY2msMeXFC9gNg-A86R9ZU_T0PoROof0u1eJHYVlmo_dv2fodyNqkDB8V6HK3vqf7jaqNQtk8Fg6eHKhwb-3bAtjb5cpWAAWhMSrHZzTWIYUvYsvwAas5ihgenv3UOkpcl_p7b7G9SDhGE5abPQQ7lvyfhYZE7CV1DzVRU6UL4N0D2l4uI3RJNOQoECvltfo2etYzp5viwAwvg9LUS3466Ra1i8beBKXsPFQ', 'id_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZW1haWwiOiJmcmFuY29pcyt0ZXN0QGZpZWYuZGV2IiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInN1YiI6ImEzODQ2Y2MxLTdjMDgtNDM4OS04YzhlLWMwZTc5ZjcwNzVmZSIsInRlbmFudF9pZCI6IjcwNDEzNWI2LTRiZmQtNGM1NS04MDkwLWM2MzhhNmJhNTNhMiJ9.ULQy7TlgF5_oQwwgA6ydTahTYE31obr4F3olJy-mgyPw67XstoJLM1VwUNawzyz2Iu2QDmgcBrH3OMVfgCkBAFk2sp-QQIDr9arIF1QXNKG65El3zgPQ5-niTTsIuAkemyjNGcpdrcN2b9FaeodzauO5eOjno60h5dTBbcLnqv00V-Jv6sq8lB8_o5JXHKWUoZZA2VFEDox9MXfhDqrvyHcitsIRWIy7XhILKcZ-JG_AMcXnuDcyMnsoy91-gJznvMk7_ty9eNWs8Cm0ZhK3nMqEKML4tXIREmIN-vYUGDtbDWX3O45N98ovu9gJi9S3aVOh-gZQsnwauJmlW82ZQQ', 'token_type': 'bearer', 'expires_in': 3600} Userinfo: {'aud': ['YOUR_CLIENT_ID'], 'azp': 'YOUR_CLIENT_ID', 'email': 'anne@bretagne.duchy', 'exp': 1648050423, 'iat': 1648046823, 'iss': 'https://example.fief.dev', 'sub': 'a3846cc1-7c08-4389-8c8e-c0e79f7075fe', 'tenant_id': '704135b6-4bfd-4c55-8090-c638a6ba53a2'} As you can see, we obtained a first dictionary tokens containing an access token, an ID token and other standard OAuth2 information. The second variable, userinfo , is a dictionary with the user data. It's actually the information contained in the ID token that the client decoded for you.","title":"Test it"},{"location":"integrate/python/#whats-next","text":"You have the fundamental basics for performing an OAuth2 authentication with the Fief Python client. To help you further, we provide you helpers and examples for popular Python frameworks like Flask or FastAPI. Integrate with FastAPI Integrate with Flask","title":"What's next?"},{"location":"integrate/python/#reference","text":"","title":"Reference"},{"location":"integrate/python/#auth_url","text":"Returns an authorization URL. Parameters redirect_uri: str : Your callback URI where the user will be redirected after the service prompt. state: str = None : Optional string that will be returned back in the callback parameters to allow you to retrieve state information. scope: Optional[List[str]] = None : Optional list of scopes to ask for. extras_params: Optional[Dict[str, Any]] = None : Optional dictionary containing specific parameters. Example auth_url = fief . auth_url ( \"http://localhost:8000/callback\" , scope = [ \"openid\" ])","title":"auth_url"},{"location":"integrate/python/#auth_callback","text":"Returns valid tokens and user info in exchange of an authorization code. Parameters code: str : The authorization code. redirect_uri: str : The exact same redirect_uri you passed to the authorization URL. Example tokens , userinfo = fief . auth_callback ( \"CODE\" , \"http://localhost:8000/callback\" )","title":"auth_callback"},{"location":"integrate/python/#auth_refresh_token","text":"Returns fresh tokens and user info in exchange of a refresh token. Parameters refresh_token: str : A valid refresh token. scope: Optional[List[str]] = None : Optional list of scopes to ask for. If not provided, the access token will share the same list of scopes as requested the first time. Otherwise, it should be a subset of the original list of scopes. Example tokens , userinfo = fief . auth_refresh_token ( \"REFRESH_TOKEN\" )","title":"auth_refresh_token"},{"location":"integrate/python/#validate_access_token","text":"Checks if an access token is valid and optionally that it has a required list of scopes. Parameters access_token: str : The access token to validate. required_scope: Optional[List[str]] = None : Optional list of scopes to check for. Example from fief_client import FiefAccessTokenInvalid , FiefAccessTokenExpired , FiefAccessTokenMissingScope try : access_token_info = fief . validate_access_token ( \"ACCESS_TOKEN\" , required_scope = [ \"required_scope\" ]) except FiefAccessTokenInvalid : print ( \"Invalid access token\" ) except FiefAccessTokenExpired : print ( \"Expired access token\" ) except FiefAccessTokenMissingScope : print ( \"Missing required scope\" ) print ( access_token_info ) # {\"id\": \"USER_ID\", \"scope\": [\"openid\", \"required_scope\"], \"access_token\": \"ACCESS_TOKEN\"}","title":"validate_access_token"},{"location":"integrate/python/#userinfo","text":"Returns fresh user information from the Fief API using a valid access token. Parameters access_token: str : A valid access token Example userinfo = fief . userinfo ( \"ACCESS_TOKEN\" )","title":"userinfo"},{"location":"integrate/python/fastapi/","text":"FastAPI FastAPI is one of the fastest-growing Python web framework. It features impressive performance and top-notch developer experience. Actually, the Fief server itself is implemented with FastAPI! The Fief Python client provides tools to help you integrate Fief authentication in your FastAPI project. Let's see how to use them! Install the client Install the Fief client with the optional FastAPI dependencies: pip install \"fief-client[fastapi]\" API example This is for you if... Your FastAPI backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. In this first example, we'll leverage the interactive documentation generated by FastAPI to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( # (2)! \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) # (3)! app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ()), # (4)! ): return access_token_info Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Notice here that we use the FiefAsync class. FastAPI being an ASGI framework, it's always nice to take advantage of asyncio capabilities. OpenAPI security scheme FastAPI uses those security schemes to generate an interactive documentation showing the right interface to authenticate with the API. We use here a standard OAuth2 interface. Fief helper for FastAPI This is the helper doing the tedious work for you with FastAPI. All it needs is an instance of the Fief client and the scheme. current_user dependency This is where the magic happens: in pure FastAPI style, FiefAuth gives you a current_user dependency to check for the access token and optionally for required scopes. If everything goes well, you'll get a dictionary containing the ID of the user, the list of allowed scopes and the raw access token. And that's about it! Test it You can run this example just like you would do for any FastAPI app: uvicorn app:app Open http://localhost:8000/docs to access the interactive documentation. Let's try first the /user endpoint: We get an 401 error! That's expected: we are not authenticated yet ! Let's fix that: click on the Authorize button to start the authentication process. You'll need to provide your client ID and secret and select the scopes. Click on the Authorize button: you are redirected to the Fief login page. Upon successful login, you will be redirected back to the interactive documentation: a valid access token has been generated! You can now try the /user endpoint to check the result: Notice how the interactive documentation passed the access token in the Authorization header of the request! Besides, the response does contain the user ID, the list of allowed scopes and the access token itself. Checking for scopes Building on the previous example, you can make your endpoint requires the access token to be granted a list of scopes . Simply add this list of scopes as a parameter of the current_user dependency. app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ([ \"openid\" , \"required_scope\" ]) ), ): return access_token_info If one of the required scope is missing on the access token, a 403 Forbidden error will automatically be returned. Web application example This is for you if... Your FastAPI backend will render HTML pages. Your application is intended to be used in a browser. The examples we showed previously are working well in a pure REST API context: a frontend, like the interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application, where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py from datetime import datetime from fastapi import Depends , FastAPI , HTTPException , Query , Request , Response , status from fastapi.responses import HTMLResponse , RedirectResponse from fastapi.security import APIKeyCookie from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth class CustomFiefAuth ( FiefAuth ): # (1)! client : FiefAsync async def get_unauthorized_response ( self , request : Request , response : Response ): redirect_uri = request . url_for ( \"auth_callback\" ) # (2)! auth_url = await self . client . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (3)! raise HTTPException ( status_code = status . HTTP_307_TEMPORARY_REDIRECT , # (4)! headers = { \"Location\" : auth_url }, ) fief = FiefAsync ( # (5)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) SESSION_COOKIE_NAME = \"user_session\" scheme = APIKeyCookie ( name = SESSION_COOKIE_NAME , auto_error = False ) # (6)! auth = CustomFiefAuth ( fief , scheme ) # (7)! app = FastAPI () @app . get ( \"/auth-callback\" , name = \"auth_callback\" ) # (8)! async def auth_callback ( request : Request , response : Response , code : str = Query ( ... )): redirect_uri = request . url_for ( \"auth_callback\" ) tokens , _ = await fief . auth_callback ( code , redirect_uri ) # (9)! response = RedirectResponse ( request . url_for ( \"protected\" )) # (10)! response . set_cookie ( # (11)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (12)! secure = False , # \u274c Set this to `True` in production (13)! ) return response @app . get ( \"/protected\" , name = \"protected\" ) async def protected ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ()), # (14)! ): return HTMLResponse ( f \"<h1>You are authenticated. Your user ID is { access_token_info [ 'id' ] } </h1>\" ) We customize the FiefAuth helper to fit our needs The base class is implemented with an API scenario in mind. Nevertheless, it's designed in a way you can customize its behavior when the user is not authenticated or has not the required scope. That's what'll do with the get_unauthorized_response . We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server The base class is implemented with an API scenario in mind. Nevertheless, it's designed in a way you can customize its behavior when the user is not authenticated or has not the required scope. That's what'll do with the get_unauthorized_response . We build a redirect response By setting a status code in the 3XX range, we tell the browser that it should redirect the user to another URL, specified in the Location header. You can read more about HTTP redirections on the MDN documentation . This doesn't change from the previous example The FiefAsync client is always at the heart of the integration \ud83d\ude09 We use a scheme expecting a cookie Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use a dedicated scheme for that. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. Besides, we set the auto_error argument to False . It tells FastAPI user to bypass its built-in error response if the cookie is not present: we have our own logic to handle this. We use our custom CustomFiefAuth class Of course, now that we overloaded the behavior of this helper class, we shouldn't forget to actually use it! We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. Notice that we set its name parameter: this is how we can generate its URL automatically with the request.url_for method. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. Use the current_user dependency as usual This doesn't change from the previous example. The dependency will check if the cookie is available in the request and proceed if everything goes well. Otherwise, our custom get_unauthorized_response will be called and the user will be redirected to the Fief login page. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.","title":"FastAPI"},{"location":"integrate/python/fastapi/#fastapi","text":"FastAPI is one of the fastest-growing Python web framework. It features impressive performance and top-notch developer experience. Actually, the Fief server itself is implemented with FastAPI! The Fief Python client provides tools to help you integrate Fief authentication in your FastAPI project. Let's see how to use them!","title":"FastAPI"},{"location":"integrate/python/fastapi/#install-the-client","text":"Install the Fief client with the optional FastAPI dependencies: pip install \"fief-client[fastapi]\"","title":"Install the client"},{"location":"integrate/python/fastapi/#api-example","text":"This is for you if... Your FastAPI backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. In this first example, we'll leverage the interactive documentation generated by FastAPI to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( # (2)! \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) # (3)! app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ()), # (4)! ): return access_token_info Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Notice here that we use the FiefAsync class. FastAPI being an ASGI framework, it's always nice to take advantage of asyncio capabilities. OpenAPI security scheme FastAPI uses those security schemes to generate an interactive documentation showing the right interface to authenticate with the API. We use here a standard OAuth2 interface. Fief helper for FastAPI This is the helper doing the tedious work for you with FastAPI. All it needs is an instance of the Fief client and the scheme. current_user dependency This is where the magic happens: in pure FastAPI style, FiefAuth gives you a current_user dependency to check for the access token and optionally for required scopes. If everything goes well, you'll get a dictionary containing the ID of the user, the list of allowed scopes and the raw access token. And that's about it!","title":"API example"},{"location":"integrate/python/fastapi/#test-it","text":"You can run this example just like you would do for any FastAPI app: uvicorn app:app Open http://localhost:8000/docs to access the interactive documentation. Let's try first the /user endpoint: We get an 401 error! That's expected: we are not authenticated yet ! Let's fix that: click on the Authorize button to start the authentication process. You'll need to provide your client ID and secret and select the scopes. Click on the Authorize button: you are redirected to the Fief login page. Upon successful login, you will be redirected back to the interactive documentation: a valid access token has been generated! You can now try the /user endpoint to check the result: Notice how the interactive documentation passed the access token in the Authorization header of the request! Besides, the response does contain the user ID, the list of allowed scopes and the access token itself.","title":"Test it"},{"location":"integrate/python/fastapi/#checking-for-scopes","text":"Building on the previous example, you can make your endpoint requires the access token to be granted a list of scopes . Simply add this list of scopes as a parameter of the current_user dependency. app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ([ \"openid\" , \"required_scope\" ]) ), ): return access_token_info If one of the required scope is missing on the access token, a 403 Forbidden error will automatically be returned.","title":"Checking for scopes"},{"location":"integrate/python/fastapi/#web-application-example","text":"This is for you if... Your FastAPI backend will render HTML pages. Your application is intended to be used in a browser. The examples we showed previously are working well in a pure REST API context: a frontend, like the interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application, where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py from datetime import datetime from fastapi import Depends , FastAPI , HTTPException , Query , Request , Response , status from fastapi.responses import HTMLResponse , RedirectResponse from fastapi.security import APIKeyCookie from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth class CustomFiefAuth ( FiefAuth ): # (1)! client : FiefAsync async def get_unauthorized_response ( self , request : Request , response : Response ): redirect_uri = request . url_for ( \"auth_callback\" ) # (2)! auth_url = await self . client . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (3)! raise HTTPException ( status_code = status . HTTP_307_TEMPORARY_REDIRECT , # (4)! headers = { \"Location\" : auth_url }, ) fief = FiefAsync ( # (5)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) SESSION_COOKIE_NAME = \"user_session\" scheme = APIKeyCookie ( name = SESSION_COOKIE_NAME , auto_error = False ) # (6)! auth = CustomFiefAuth ( fief , scheme ) # (7)! app = FastAPI () @app . get ( \"/auth-callback\" , name = \"auth_callback\" ) # (8)! async def auth_callback ( request : Request , response : Response , code : str = Query ( ... )): redirect_uri = request . url_for ( \"auth_callback\" ) tokens , _ = await fief . auth_callback ( code , redirect_uri ) # (9)! response = RedirectResponse ( request . url_for ( \"protected\" )) # (10)! response . set_cookie ( # (11)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (12)! secure = False , # \u274c Set this to `True` in production (13)! ) return response @app . get ( \"/protected\" , name = \"protected\" ) async def protected ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ()), # (14)! ): return HTMLResponse ( f \"<h1>You are authenticated. Your user ID is { access_token_info [ 'id' ] } </h1>\" ) We customize the FiefAuth helper to fit our needs The base class is implemented with an API scenario in mind. Nevertheless, it's designed in a way you can customize its behavior when the user is not authenticated or has not the required scope. That's what'll do with the get_unauthorized_response . We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server The base class is implemented with an API scenario in mind. Nevertheless, it's designed in a way you can customize its behavior when the user is not authenticated or has not the required scope. That's what'll do with the get_unauthorized_response . We build a redirect response By setting a status code in the 3XX range, we tell the browser that it should redirect the user to another URL, specified in the Location header. You can read more about HTTP redirections on the MDN documentation . This doesn't change from the previous example The FiefAsync client is always at the heart of the integration \ud83d\ude09 We use a scheme expecting a cookie Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use a dedicated scheme for that. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. Besides, we set the auto_error argument to False . It tells FastAPI user to bypass its built-in error response if the cookie is not present: we have our own logic to handle this. We use our custom CustomFiefAuth class Of course, now that we overloaded the behavior of this helper class, we shouldn't forget to actually use it! We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. Notice that we set its name parameter: this is how we can generate its URL automatically with the request.url_for method. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. Use the current_user dependency as usual This doesn't change from the previous example. The dependency will check if the cookie is available in the request and proceed if everything goes well. Otherwise, our custom get_unauthorized_response will be called and the user will be redirected to the Fief login page. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.","title":"Web application example"},{"location":"integrate/python/flask/","text":"Flask","title":"Flask"},{"location":"integrate/python/flask/#flask","text":"","title":"Flask"},{"location":"miscellaneous/resources/","text":"Resources RFC7517 (JSON Web Key): https://datatracker.ietf.org/doc/html/rfc7517 RFC7636 (OAuth2 PKCE): https://datatracker.ietf.org/doc/html/rfc7636 OpenID Connect 1.0 specification: https://openid.net/specs/openid-connect-core-1_0.html JWCrypto's library documentation: https://jwcrypto.readthedocs.io/","title":"Resources"},{"location":"miscellaneous/resources/#resources","text":"RFC7517 (JSON Web Key): https://datatracker.ietf.org/doc/html/rfc7517 RFC7636 (OAuth2 PKCE): https://datatracker.ietf.org/doc/html/rfc7636 OpenID Connect 1.0 specification: https://openid.net/specs/openid-connect-core-1_0.html JWCrypto's library documentation: https://jwcrypto.readthedocs.io/","title":"Resources"},{"location":"partials/client-callout/","text":"What is a client? A client is a central part of the OAuth2 protocol. It's the definition of an application authorized to request for access tokens and user information on Fief. In other words, your application will need one of those client to be able to authenticate users from your Fief workspace. Each client has a Client ID and a Client Secret. Those values are used during OAuth2 authentification to recognize the client. Each workspace comes with one client, tied to the default tenant .","title":"Client callout"},{"location":"partials/environment-variables-callout/","text":"Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Environment variables callout"},{"location":"partials/tenant-callout/","text":"What is a tenant? A tenant is a sub-division of your workspace. Each client and user is tied to a specific tenant. This is mostly useful if you want to create a product sold in white-label where each of your client has its own space. It allows for example for a user to have several accounts with the same email address inside one workspace, but actually tied to different tenants. From a user point-of-view, this is a different application on which they login with different credentials. If you don't plan to do this, that's okay: you'll always use a single tenant in your workspace. Each workspace has at least one default tenant.","title":"Tenant callout"},{"location":"partials/workspace-callout/","text":"What is a workspace? A workspace is a place where all your Fief data lives: configuration, users data, etc. Each workspace has its own subdomain reserved for you, like https://example.fief.dev . If you are working on several projects or companies, we recommend to create several workspaces to keep things organized.","title":"Workspace callout"},{"location":"self-hosting/environment-variables/","text":"Environment variables Fief server relies heavily on environment variables for configuration. You'll likely need to adjust those settings for your deployment. Set environment variables Using docker run When running Fief server with Docker, the most straightforward way is to use the -e option on the command line, as shown in the Quickstart section. docker run \\ --name fief-server \\ -p 8000 :80 -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest However, it may become hard to maintain when having lot of variables to set. An alternative way is to use a .env file. It's a simple file where each line consists of a key and a value separated by an equal sign: .env SECRET = XXX FIEF_CLIENT_ID = XXX FIEF_CLIENT_SECRET = XXX ENCRYPTION_KEY = XXX Then, you can reference this file in the Docker command: docker run \\ --name fief-server \\ -p 8000 :80 -d \\ --env-file .env \\ ghcr.io/fief-dev/fief:latest Using Docker Compose For more complex setups, you may need to configure a Docker Compose file to help you manage all your containers. You can directly define your environment variables in the Compose file. You'll find below an example of a Docker Compose file to run the Fief server. docker-compose.yml version : \"3.9\" services : fief : image : ghcr.io/fief-dev/fief:latest ports : - \"80:8000\" environment : - SECRET=XXX - FIEF_CLIENT_ID=XXX - FIEF_CLIENT_SECRET=XXX - ENCRYPTION_KEY=XXX Reference For each variable, we'll try to provide a sensible example value to help you configure it correctly. Throughout the examples, we'll assume that you host your Fief server on the sub-domain fief.bretagne.duchy . General Name Description Default Allowed values Example ENVIRONMENT Name of the deployment environment development development, staging, production production LOG_LEVEL Log verbosity DEBUG DEBUG, INFO, WARNING, ERROR INFO ROOT_DOMAIN Root domain where your server will be running. Mainly used for generating workspace subdomains. localhost bretagne.duchy ALLOW_ORIGIN_REGEX Regex used to control CORS access to your API http://.*localhost:[0-9]+ https://.*\\.bretagne.duchy Secrets Name Description Default Allowed values Example SECRET Secret value used to sign reset password tokens. Any sufficiently long string ENCRYPTION_KEY Key used to encrypt the external databases credentials inside the main database A valid Fernet key encoded in UTF-8 Database Name Description Default Allowed values Example DATABASE_TYPE Type of the main database SQLITE POSTGRESQL, MYSQL, SQLITE POSTGRESQL DATABASE_HOST Host of the main database localhost DATABASE_PORT Listening port of the main database 5432 DATABASE_USERNAME Main database user fief DATABASE_PASSWORD Main database user's password fiefpassword DATABASE_NAME Main database name fief.db fief DATABASE_LOCATION For SQLite databases, path where to store the database files Current working directory DATABASE_URL Full database connection string, useful for some cloud providers. It'll take precedence over the single parameters above. More details about how to setup a database in the dedicated section. Setup database Redis We use a Redis instance to manage background jobs (send emails, heavy computations...). A Redis instance is already up-and-running in the official Docker image, but you can provide your own one if needed. Name Description Default Allowed values Example REDIS_URL URL of a Redis server redis://localhost:6379 Email provider Name Description Default Allowed values Example EMAIL_PROVIDER Type of email provider NULL NULL, POSTMARK POSTMARK EMAIL_PROVIDER_PARAMS Configuration dictionary of the email provider {} {\"server_token\": \"XXX-XXX\"} More details about how to setup an email provider in the dedicated section. Setup email provider CSRF cookie To protect against Cross-Site-Request-Forgery attacks on authentication pages, we use the double-submit cookie pattern. Name Description Default Allowed values Example CSRF_COOKIE_NAME Name of the CSRF token cookie fief_csrftoken CSRF_COOKIE_SECURE Secure flag of the login session cookie True Login session A login session is a cookie used to maintain the state of the login flow of a user, from the login page until they're redirected to your application. Name Description Default Allowed values Example LOGIN_SESSION_COOKIE_NAME Name of the login session cookie fief_login_session LOGIN_SESSION_COOKIE_DOMAIN Domain of the login session cookie Empty string LOGIN_SESSION_COOKIE_SECURE Secure flag of the login session cookie True Session A session is a cookie used to maintain the session of a user on the Fief authentication pages . It's different from the session you'll maintain in your own application. Its purpose is to allow a user to re-authenticate quickly to your app without having them to input their credentials again. Name Description Default Allowed values Example SESSION_COOKIE_NAME Name of the session cookie fief_session SESSION_COOKIE_DOMAIN Domain of the session cookie Empty string SESSION_COOKIE_SECURE Secure flag of the session cookie True SESSION_LIFETIME_SECONDS Lifetime of the session cookie in seconds 86400 * 30 (30 days ) Fief-ception Fief-ception is a mind-fucking concept describing the fact that we actually use Fief to authenticate Fief users to the app \ud83e\udd2f That's why we necessarily need to create a first workspace and an admin user before being able to use Fief, as described in the Quickstart section. The variables below are here to configure the Fief server with a proper Fief client, as you would do in your own application! Name Description Default Allowed values Example FIEF_DOMAIN Domain of your main Fief workspace localhost fief.bretagne.duchy FIEF_BASE_URL URL of the main Fief workspace. It calls itself! http://localhost https://fief.bretagne.duchy FIEF_CLIENT_ID Client ID in your main Fief workspace FIEF_CLIENT_SECRET Client secret in your main Fief workspace FIEF_ENCRYPTION_KEY Optional RSA key used to encrypt the JWT tokens Admin session An admin session is a cookie used to maintain the session of a user on the Fief admin dashboard. Name Description Default Allowed values Example FIEF_ADMIN_SESSION_COOKIE_NAME Name of the admin session cookie fief_admin_session FIEF_ADMIN_SESSION_COOKIE_DOMAIN Domain of the admin session cookie Empty string FIEF_ADMIN_SESSION_COOKIE_SECURE Secure flag of the admin session cookie True","title":"Environment variables"},{"location":"self-hosting/environment-variables/#environment-variables","text":"Fief server relies heavily on environment variables for configuration. You'll likely need to adjust those settings for your deployment.","title":"Environment variables"},{"location":"self-hosting/environment-variables/#set-environment-variables","text":"","title":"Set environment variables"},{"location":"self-hosting/environment-variables/#using-docker-run","text":"When running Fief server with Docker, the most straightforward way is to use the -e option on the command line, as shown in the Quickstart section. docker run \\ --name fief-server \\ -p 8000 :80 -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest However, it may become hard to maintain when having lot of variables to set. An alternative way is to use a .env file. It's a simple file where each line consists of a key and a value separated by an equal sign: .env SECRET = XXX FIEF_CLIENT_ID = XXX FIEF_CLIENT_SECRET = XXX ENCRYPTION_KEY = XXX Then, you can reference this file in the Docker command: docker run \\ --name fief-server \\ -p 8000 :80 -d \\ --env-file .env \\ ghcr.io/fief-dev/fief:latest","title":"Using docker run"},{"location":"self-hosting/environment-variables/#using-docker-compose","text":"For more complex setups, you may need to configure a Docker Compose file to help you manage all your containers. You can directly define your environment variables in the Compose file. You'll find below an example of a Docker Compose file to run the Fief server. docker-compose.yml version : \"3.9\" services : fief : image : ghcr.io/fief-dev/fief:latest ports : - \"80:8000\" environment : - SECRET=XXX - FIEF_CLIENT_ID=XXX - FIEF_CLIENT_SECRET=XXX - ENCRYPTION_KEY=XXX","title":"Using Docker Compose"},{"location":"self-hosting/environment-variables/#reference","text":"For each variable, we'll try to provide a sensible example value to help you configure it correctly. Throughout the examples, we'll assume that you host your Fief server on the sub-domain fief.bretagne.duchy .","title":"Reference"},{"location":"self-hosting/environment-variables/#general","text":"Name Description Default Allowed values Example ENVIRONMENT Name of the deployment environment development development, staging, production production LOG_LEVEL Log verbosity DEBUG DEBUG, INFO, WARNING, ERROR INFO ROOT_DOMAIN Root domain where your server will be running. Mainly used for generating workspace subdomains. localhost bretagne.duchy ALLOW_ORIGIN_REGEX Regex used to control CORS access to your API http://.*localhost:[0-9]+ https://.*\\.bretagne.duchy","title":"General"},{"location":"self-hosting/environment-variables/#secrets","text":"Name Description Default Allowed values Example SECRET Secret value used to sign reset password tokens. Any sufficiently long string ENCRYPTION_KEY Key used to encrypt the external databases credentials inside the main database A valid Fernet key encoded in UTF-8","title":"Secrets"},{"location":"self-hosting/environment-variables/#database","text":"Name Description Default Allowed values Example DATABASE_TYPE Type of the main database SQLITE POSTGRESQL, MYSQL, SQLITE POSTGRESQL DATABASE_HOST Host of the main database localhost DATABASE_PORT Listening port of the main database 5432 DATABASE_USERNAME Main database user fief DATABASE_PASSWORD Main database user's password fiefpassword DATABASE_NAME Main database name fief.db fief DATABASE_LOCATION For SQLite databases, path where to store the database files Current working directory DATABASE_URL Full database connection string, useful for some cloud providers. It'll take precedence over the single parameters above. More details about how to setup a database in the dedicated section. Setup database","title":"Database"},{"location":"self-hosting/environment-variables/#redis","text":"We use a Redis instance to manage background jobs (send emails, heavy computations...). A Redis instance is already up-and-running in the official Docker image, but you can provide your own one if needed. Name Description Default Allowed values Example REDIS_URL URL of a Redis server redis://localhost:6379","title":"Redis"},{"location":"self-hosting/environment-variables/#email-provider","text":"Name Description Default Allowed values Example EMAIL_PROVIDER Type of email provider NULL NULL, POSTMARK POSTMARK EMAIL_PROVIDER_PARAMS Configuration dictionary of the email provider {} {\"server_token\": \"XXX-XXX\"} More details about how to setup an email provider in the dedicated section. Setup email provider","title":"Email provider"},{"location":"self-hosting/environment-variables/#csrf-cookie","text":"To protect against Cross-Site-Request-Forgery attacks on authentication pages, we use the double-submit cookie pattern. Name Description Default Allowed values Example CSRF_COOKIE_NAME Name of the CSRF token cookie fief_csrftoken CSRF_COOKIE_SECURE Secure flag of the login session cookie True","title":"CSRF cookie"},{"location":"self-hosting/environment-variables/#login-session","text":"A login session is a cookie used to maintain the state of the login flow of a user, from the login page until they're redirected to your application. Name Description Default Allowed values Example LOGIN_SESSION_COOKIE_NAME Name of the login session cookie fief_login_session LOGIN_SESSION_COOKIE_DOMAIN Domain of the login session cookie Empty string LOGIN_SESSION_COOKIE_SECURE Secure flag of the login session cookie True","title":"Login session"},{"location":"self-hosting/environment-variables/#session","text":"A session is a cookie used to maintain the session of a user on the Fief authentication pages . It's different from the session you'll maintain in your own application. Its purpose is to allow a user to re-authenticate quickly to your app without having them to input their credentials again. Name Description Default Allowed values Example SESSION_COOKIE_NAME Name of the session cookie fief_session SESSION_COOKIE_DOMAIN Domain of the session cookie Empty string SESSION_COOKIE_SECURE Secure flag of the session cookie True SESSION_LIFETIME_SECONDS Lifetime of the session cookie in seconds 86400 * 30 (30 days )","title":"Session"},{"location":"self-hosting/environment-variables/#fief-ception","text":"Fief-ception is a mind-fucking concept describing the fact that we actually use Fief to authenticate Fief users to the app \ud83e\udd2f That's why we necessarily need to create a first workspace and an admin user before being able to use Fief, as described in the Quickstart section. The variables below are here to configure the Fief server with a proper Fief client, as you would do in your own application! Name Description Default Allowed values Example FIEF_DOMAIN Domain of your main Fief workspace localhost fief.bretagne.duchy FIEF_BASE_URL URL of the main Fief workspace. It calls itself! http://localhost https://fief.bretagne.duchy FIEF_CLIENT_ID Client ID in your main Fief workspace FIEF_CLIENT_SECRET Client secret in your main Fief workspace FIEF_ENCRYPTION_KEY Optional RSA key used to encrypt the JWT tokens","title":"Fief-ception"},{"location":"self-hosting/environment-variables/#admin-session","text":"An admin session is a cookie used to maintain the session of a user on the Fief admin dashboard. Name Description Default Allowed values Example FIEF_ADMIN_SESSION_COOKIE_NAME Name of the admin session cookie fief_admin_session FIEF_ADMIN_SESSION_COOKIE_DOMAIN Domain of the admin session cookie Empty string FIEF_ADMIN_SESSION_COOKIE_SECURE Secure flag of the admin session cookie True","title":"Admin session"},{"location":"self-hosting/quickstart/","text":"Quickstart We provide a Docker image to help you start the Fief server locally in no time! Run the following command: docker run --rm ghcr.io/fief-dev/fief:latest fief quickstart --docker The result of this command is a complete docker run command with the required secrets generated to help you get started. It'll look like the following: docker run \\ --name fief-server \\ -p 8000 :80 -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest Save those secrets somewhere safe! If you need restart or recreate your container, you'll probably need to set the same secrets again. If you lose them, you'll likely lose access to data or have a bad configuration. Read more about secrets and environment variables. Info The container is exposed on the port 8000 of your local machine by default, but you can set any port you want. Create main workspace Next, you'll need to create the main workspace . Simply run the following command: docker exec fief-server fief create-main-workspace You should see the following output: Main Fief workspace created Create admin user Finally, you need to create an admin user for this main workspace that'll have access to the admin dashboard. Run the following command: docker exec -it fief-server fief create-main-user --user-email anne@bretagne.duchy Tip Of course, make sure to replace --user-email value with your own email address! You'll then be prompted for a password. If everything goes well, you should see the following output: Main Fief user created Good to go! At this point, your Fief server should be up-and-running! Open http://localhost:8000/admin/ to access the admin dashboard. You'll be redirected to a login page. Authenticate with the user credentials you created in the previous section. You'll then be redirected to the admin dashboard. Congratulations! Your Fief server instance is up-and-running \ud83c\udf89 You can now try Fief features and start to integrate authentication in your app. Tip For production deployment, we strongly recommend you to read the next sections. Limitations While quick and convenient, this way of running Fief is not suitable for production environments . Under the hood, it stores the data in the form of SQLite databases . If you ever happen to destroy your container, you'll lose all your data. The best way is of course to configure a proper PostgreSQL or MySQL database for your Fief server, as described in the dedicated section. Setup database Use a Docker volume to persist SQLite data If you really want to use SQLite, or mitigate the risk of losing data in your local environment, you can attach your container to a Docker volume . This way, even if the container is destroyed, you can create a new one and attach again the data. The first thing to do is to create a Docker volume: docker volume create fief-server-data Then, create your Fief server container and attach this volume to the /data folder on the container: docker run \\ --name fief-server \\ -p 8000 :80 -d \\ -v fief-server-volume:/data \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest Warning If you created your container with the instructions in the previous section, you'll need to recreate one from scratch to bind the volume.","title":"Quickstart"},{"location":"self-hosting/quickstart/#quickstart","text":"We provide a Docker image to help you start the Fief server locally in no time! Run the following command: docker run --rm ghcr.io/fief-dev/fief:latest fief quickstart --docker The result of this command is a complete docker run command with the required secrets generated to help you get started. It'll look like the following: docker run \\ --name fief-server \\ -p 8000 :80 -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest Save those secrets somewhere safe! If you need restart or recreate your container, you'll probably need to set the same secrets again. If you lose them, you'll likely lose access to data or have a bad configuration. Read more about secrets and environment variables. Info The container is exposed on the port 8000 of your local machine by default, but you can set any port you want.","title":"Quickstart"},{"location":"self-hosting/quickstart/#create-main-workspace","text":"Next, you'll need to create the main workspace . Simply run the following command: docker exec fief-server fief create-main-workspace You should see the following output: Main Fief workspace created","title":"Create main workspace"},{"location":"self-hosting/quickstart/#create-admin-user","text":"Finally, you need to create an admin user for this main workspace that'll have access to the admin dashboard. Run the following command: docker exec -it fief-server fief create-main-user --user-email anne@bretagne.duchy Tip Of course, make sure to replace --user-email value with your own email address! You'll then be prompted for a password. If everything goes well, you should see the following output: Main Fief user created","title":"Create admin user"},{"location":"self-hosting/quickstart/#good-to-go","text":"At this point, your Fief server should be up-and-running! Open http://localhost:8000/admin/ to access the admin dashboard. You'll be redirected to a login page. Authenticate with the user credentials you created in the previous section. You'll then be redirected to the admin dashboard. Congratulations! Your Fief server instance is up-and-running \ud83c\udf89 You can now try Fief features and start to integrate authentication in your app. Tip For production deployment, we strongly recommend you to read the next sections.","title":"Good to go!"},{"location":"self-hosting/quickstart/#limitations","text":"While quick and convenient, this way of running Fief is not suitable for production environments . Under the hood, it stores the data in the form of SQLite databases . If you ever happen to destroy your container, you'll lose all your data. The best way is of course to configure a proper PostgreSQL or MySQL database for your Fief server, as described in the dedicated section. Setup database","title":"Limitations"},{"location":"self-hosting/quickstart/#use-a-docker-volume-to-persist-sqlite-data","text":"If you really want to use SQLite, or mitigate the risk of losing data in your local environment, you can attach your container to a Docker volume . This way, even if the container is destroyed, you can create a new one and attach again the data. The first thing to do is to create a Docker volume: docker volume create fief-server-data Then, create your Fief server container and attach this volume to the /data folder on the container: docker run \\ --name fief-server \\ -p 8000 :80 -d \\ -v fief-server-volume:/data \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest Warning If you created your container with the instructions in the previous section, you'll need to recreate one from scratch to bind the volume.","title":"Use a Docker volume to persist SQLite data"},{"location":"self-hosting/setup-database/","text":"Setup database For production environments, your Fief server should store its data in a proper database server for better performance and reliability. Fief is compatible with PostgreSQL and MySQL databases. Setup PostgreSQL We'll assume that you have a working PostgreSQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = POSTGRESQL DATABASE_HOST = localhost DATABASE_PORT = 5432 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section . Setup MySQL We'll assume that you have a working MySQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = MYSQL DATABASE_HOST = localhost DATABASE_PORT = 3306 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section . Use a connection string Some cloud providers like Heroku will provide you a full database connection string like the one below instead of each parts separately: postgresql://fief:fiefpassword@localhost:5432/fief Fief supports this kind of configuration with the DATABASE_URL environment variable. DATABASE_TYPE = POSTGRESQL DATABASE_URL = postgresql://fief:fiefpassword@localhost:5432/fief Warning This variable will always take precedence over the single parameters: if you define DATABASE_URL , it'll use this variable to connect to your database, even if other parameters are defined. Create main workspace and admin user Once your database is configured, don't forget to create the main workspace and admin user, as described in the Quickstart section.","title":"Setup database"},{"location":"self-hosting/setup-database/#setup-database","text":"For production environments, your Fief server should store its data in a proper database server for better performance and reliability. Fief is compatible with PostgreSQL and MySQL databases.","title":"Setup database"},{"location":"self-hosting/setup-database/#setup-postgresql","text":"We'll assume that you have a working PostgreSQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = POSTGRESQL DATABASE_HOST = localhost DATABASE_PORT = 5432 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Setup PostgreSQL"},{"location":"self-hosting/setup-database/#setup-mysql","text":"We'll assume that you have a working MySQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = MYSQL DATABASE_HOST = localhost DATABASE_PORT = 3306 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Setup MySQL"},{"location":"self-hosting/setup-database/#use-a-connection-string","text":"Some cloud providers like Heroku will provide you a full database connection string like the one below instead of each parts separately: postgresql://fief:fiefpassword@localhost:5432/fief Fief supports this kind of configuration with the DATABASE_URL environment variable. DATABASE_TYPE = POSTGRESQL DATABASE_URL = postgresql://fief:fiefpassword@localhost:5432/fief Warning This variable will always take precedence over the single parameters: if you define DATABASE_URL , it'll use this variable to connect to your database, even if other parameters are defined.","title":"Use a connection string"},{"location":"self-hosting/setup-database/#create-main-workspace-and-admin-user","text":"Once your database is configured, don't forget to create the main workspace and admin user, as described in the Quickstart section.","title":"Create main workspace and admin user"},{"location":"self-hosting/setup-email-provider/","text":"Setup email provider As you surely now, users management imply a lot of transactional emails, like welcome emails or reset password emails. To be able to send them, Fief needs an email provider. Currently, Fief only supports Postmark , one of the leading email delivery service on the market, but we may support more in the future. There are two environment variables to configure the email provider: EMAIL_PROVIDER , to set the type of provider and EMAIL_PROVIDER_PARAMS , a configuration dictionary containing required configuration keys. NULL provider The NULL provider is the default one if you don't set any. It means that no transactional email will be sent . EMAIL_PROVIDER = NULL Postmark provider Postmark provider will send transactional emails using Postmark . Parameter Description server_token Your Postmark Server API token EMAIL_PROVIDER = POSTMARK EMAIL_PROVIDER_PARAMS = {\"server_token\": \"XXX-XXX\"} Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Setup email provider"},{"location":"self-hosting/setup-email-provider/#setup-email-provider","text":"As you surely now, users management imply a lot of transactional emails, like welcome emails or reset password emails. To be able to send them, Fief needs an email provider. Currently, Fief only supports Postmark , one of the leading email delivery service on the market, but we may support more in the future. There are two environment variables to configure the email provider: EMAIL_PROVIDER , to set the type of provider and EMAIL_PROVIDER_PARAMS , a configuration dictionary containing required configuration keys.","title":"Setup email provider"},{"location":"self-hosting/setup-email-provider/#null-provider","text":"The NULL provider is the default one if you don't set any. It means that no transactional email will be sent . EMAIL_PROVIDER = NULL","title":"NULL provider"},{"location":"self-hosting/setup-email-provider/#postmark-provider","text":"Postmark provider will send transactional emails using Postmark . Parameter Description server_token Your Postmark Server API token EMAIL_PROVIDER = POSTMARK EMAIL_PROVIDER_PARAMS = {\"server_token\": \"XXX-XXX\"} Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Postmark provider"}]}